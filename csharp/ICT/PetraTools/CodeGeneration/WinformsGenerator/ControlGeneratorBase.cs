//
// DO NOT REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// @Authors:
//       timop
//
// Copyright 2004-2011 by OM International
//
// This file is part of OpenPetra.org.
//
// OpenPetra.org is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenPetra.org is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with OpenPetra.org.  If not, see <http://www.gnu.org/licenses/>.
//
using System;
using System.Xml;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Windows.Forms;
using Ict.Tools.CodeGeneration;
using Ict.Tools.DBXML;
using Ict.Common.IO;
using Ict.Common;

namespace Ict.Tools.CodeGeneration.Winforms
{
    /// <summary>
    /// base for the control generators
    /// </summary>
    public class TControlGenerator : IControlGenerator
    {
        /// <summary>controls with this prefix should be generated by this generator</summary>
        public string FPrefix;
        /// <summary>dotnet type of the control</summary>
        public string FControlType;
        /// <summary>should the control size automatically </summary>
        public bool FAutoSize = false;
        /// <summary>is there a specified location for the control</summary>
        public bool FLocation = true;
        /// <summary>should a label be generated for this control</summary>
        public bool FGenerateLabel = true;

        /// the readonly property eg of Textbox still allows tooltips and copy to clipboard, which enable=false would not allow
        public bool FHasReadOnlyProperty = false;
        /// should the control be added to the parent container
        public bool FAddControlToContainer = true;
        /// name of the template snippet used for the code generation of the control
        public string FTemplateSnippetName = "";
        /// <summary>does this control require children</summary>
        public bool FRequiresChildren = false;
        /// <summary>default width for control</summary>
        public Int32 FDefaultWidth = 150;
        /// <summary>default height for control</summary>
        public Int32 FDefaultHeight = 28;
        /// <summary>the representation of the code to be generated</summary>
        public static TCodeStorage FCodeStorage;

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="APrefix"></param>
        /// <param name="AControlType"></param>
        public TControlGenerator(string APrefix, System.Type AControlType)
            : this(APrefix, AControlType.ToString())
        {
        }

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="APrefix"></param>
        /// <param name="AControlType"></param>
        public TControlGenerator(string APrefix, string AControlType)
        {
            FPrefix = APrefix;
            FControlType = AControlType;
            FTemplateSnippetName = AControlType;

            if (FTemplateSnippetName.IndexOf(".") != -1)
            {
                FTemplateSnippetName = FTemplateSnippetName.Substring(FTemplateSnippetName.LastIndexOf(".") + 1).ToUpper();
            }
        }

        /// <summary>
        /// should this control only be created if there are children controls? eg toolbar
        /// </summary>
        public bool RequiresChildren
        {
            get
            {
                return FRequiresChildren;
            }
        }

        /// <summary>
        /// get the label text for this control
        /// </summary>
        /// <param name="ctrl"></param>
        /// <returns></returns>
        public bool GenerateLabel(TControlDef ctrl)
        {
            if (ctrl.HasAttribute("NoLabel") && (ctrl.GetAttribute("NoLabel").ToLower() == "true"))
            {
                return false;
            }

            return FGenerateLabel;
        }

        /// <summary>
        /// dotnet type of the control
        /// </summary>
        public String ControlType
        {
            get
            {
                return FControlType;
            }
            set
            {
                FControlType = value;
            }
        }

        /// <summary>
        /// the name of the snippet in the template for Readcontrols and setcontrols, in captial letters
        /// </summary>
        public string TemplateSnippetName
        {
            get
            {
                return FTemplateSnippetName;
            }
            set
            {
                FTemplateSnippetName = value;
            }
        }

        /// <summary>
        /// should the control be added to the parent container
        /// </summary>
        public bool AddControlToContainer
        {
            get
            {
                return FAddControlToContainer;
            }
            set
            {
                FAddControlToContainer = value;
            }
        }

        /// use the prefix to see if the control matches the current class
        public bool SimplePrefixMatch(XmlNode curNode)
        {
            return curNode.Name.StartsWith(FPrefix);
        }

        /// overwrite for more complicated matches,
        /// if the same prefix is used for more than one control type
        /// e.g. txt
        public virtual bool ControlFitsNode(XmlNode curNode)
        {
            return SimplePrefixMatch(curNode);
        }

        /// <summary>
        /// declaration and code creation in the designer file
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        public virtual void GenerateDeclaration(TFormWriter writer, TControlDef ctrl)
        {
            string localControlType = ControlType;

            if (ctrl.controlType.Length > 0)
            {
                localControlType = ctrl.controlType;
            }

            writer.Template.AddToCodelet("CONTROLDECLARATION", "private " + localControlType + " " + ctrl.controlName + ";" + Environment.NewLine);
            writer.Template.AddToCodelet("CONTROLCREATION", "this." + ctrl.controlName + " = new " + localControlType + "();" + Environment.NewLine);

            // TODO generate a property that can be accessed from outside
        }

        /// <summary>
        /// how to assign a value to the control
        /// </summary>
        protected virtual string AssignValue(TControlDef ctrl, string AFieldOrNull, string AFieldTypeDotNet)
        {
            if (AFieldOrNull == null)
            {
                return ctrl.controlName + ".Value = null;";
            }

            return ctrl.controlName + ".Value = " + AFieldOrNull + ";";
        }

        /// <summary>
        /// for coding the transfer of the value from control to dataset
        /// </summary>
        /// <param name="ctrl"></param>
        /// <param name="AFieldTypeDotNet">if this is null, check for the NULL value of the control; otherwise cast the value of the control to the value of the field in the dataset</param>
        /// <returns></returns>
        protected virtual string GetControlValue(TControlDef ctrl, string AFieldTypeDotNet)
        {
            if (AFieldTypeDotNet == null)
            {
                return ctrl.controlName + ".Value == null";
            }

            return ctrl.controlName + ".Value";
        }

        /// <summary>
        /// overload
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        /// <param name="AEvent">Click or DoubleClick or other</param>
        /// <param name="ActionToPerform"></param>
        public void AssignEventHandlerToControl(TFormWriter writer, TControlDef ctrl, string AEvent, string ActionToPerform)
        {
            AssignEventHandlerToControl(writer, ctrl, AEvent, "System.EventHandler", ActionToPerform);
        }

        /// <summary>
        /// assign event handler to control
        /// </summary>
        public void AssignEventHandlerToControl(TFormWriter writer, TControlDef ctrl, string AEvent, string AEventHandlerType, string ActionToPerform)
        {
            if ((AEvent == null) || (AEvent.Length == 0))
            {
                return;
            }

            if (ActionToPerform.StartsWith("act"))
            {
                TActionHandler ActionHandler = writer.CodeStorage.FActionList[ActionToPerform];

                if (ActionHandler.actionId.Length > 0)
                {
                    // actionId is managed by FPetraUtilsObject
                    // need a special function that wraps calls to FPetraUtilsObject, otherwise problems in designer
                    ActionToPerform = ActionHandler.actionName;
                }
                else if (ActionHandler.actionClick.Length > 0)
                {
                    if (ActionHandler.actionClick.StartsWith("FPetraUtilsObject"))
                    {
                        // need a special function that wraps calls to FPetraUtilsObject, otherwise problems in designer
                        ActionToPerform = ActionHandler.actionName;
                    }
                    else
                    {
                        // direct call
                        ActionToPerform = ActionHandler.actionClick;
                    }
                }
                else
                {
                    ActionToPerform = "";
                }
            }
            else
            {
                // direct call: use ActionToPerform
            }

            if (ActionToPerform.Length > 0)
            {
                writer.SetEventHandlerToControl(ctrl.controlName, AEvent, AEventHandlerType, ActionToPerform);
            }
        }

        /// <summary>
        /// action is enabled, enable the controls depending on the action
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ActionCondition"></param>
        /// <param name="ControlName"></param>
        public void AddToActionEnabledEvent(TFormWriter writer, string ActionCondition, string ControlName)
        {
            writer.Template.AddToCodelet(
                "ENABLEDEPENDINGACTIONS_" + ActionCondition,
                ControlName + ".Enabled = e.Enabled;" + Environment.NewLine);
        }

        /// <summary>
        /// name of the event name for when the value has changed
        /// </summary>
        protected string FChangeEventName = "ValueChanged";
        /// <summary>
        /// type of the event handler for this control for the change event
        /// </summary>
        protected string FChangeEventHandlerType = "System.EventHandler";

        /// <summary>
        /// to assign event handler for the event that the value of the control has changed
        /// </summary>
        /// <returns></returns>
        public string GetEventNameForChangeEvent()
        {
            return FChangeEventName;
        }

        /// <summary>
        /// get the type of event handler for the change event for this control
        /// </summary>
        /// <returns></returns>
        public string GetEventHandlerTypeForChangeEvent()
        {
            return FChangeEventHandlerType;
        }

        /// <summary>write the code for the designer file where the properties of the control are written</summary>
        public virtual ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef ctrl)
        {
            writer.Template.AddToCodelet("CONTROLINITIALISATION",
                "//" + Environment.NewLine + "// " + ctrl.controlName + Environment.NewLine + "//" + Environment.NewLine);

            if (FLocation && !ctrl.HasAttribute("Dock"))
            {
                writer.SetControlProperty(ctrl, "Location", "new System.Drawing.Point(2,2)");
            }

            writer.SetControlProperty(ctrl, "Name", "\"" + ctrl.controlName + "\"");


            #region Aligning and stretching

            if (ctrl.HasAttribute("Align")
                && !(ctrl.HasAttribute("Stretch")))
            {
                if ((ctrl.GetAttribute("Align").ToLower() == "right")
                    || (ctrl.GetAttribute("Align").ToLower() == "top-right"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "middle-right")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Right))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "bottom-right")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "center")
                         || (ctrl.GetAttribute("Align").ToLower() == "top-center"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Top))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "middle-center")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.None))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "bottom-center")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Bottom))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "bottom")
                         || (ctrl.GetAttribute("Align").ToLower() == "bottom-left"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Bottom)))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "middle")
                         || (ctrl.GetAttribute("Align").ToLower() == "middle-left"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Left))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "left")
                         || (ctrl.GetAttribute("Align").ToLower() == "top")
                         || (ctrl.GetAttribute("Align").ToLower() == "top-left"))
                {
                    // do nothing (here just to avoid throwing the following Exception)
                    Console.WriteLine(
                        "HINT: Attribute 'Align' with value 'left', 'top' or 'top-left' does not affect the layout since these create the default alignment. Control: '"
                        +
                        ctrl.controlName + "'.");
                }
                else
                {
                    throw new Exception("Invalid value for Attribute 'Align' of Control '" + ctrl.controlName + "': '" + ctrl.GetAttribute(
                            "Align") +
                        "'. Supported values are: Simple: left, right, center; top, middle, bottom; Combined: top-left, middle-left, bottom-left, top-center, middle-center, bottom-center, top-right, middle-right, bottom-right.");
                }
            }

            if (ctrl.HasAttribute("Stretch"))
            {
                if (ctrl.GetAttribute("Stretch").ToLower() == "horizontally")
                {
                    if ((!ctrl.HasAttribute("Align"))
                        || (ctrl.HasAttribute("Align") && (ctrl.GetAttribute("Align").ToLower() == "top")))
                    {
                        // Horizontally stretched, top aligned (=default)
                        writer.SetControlProperty(
                            ctrl,
                            "Anchor",
                            "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)))");
                    }
                    else
                    {
                        if (ctrl.GetAttribute("Align").ToLower() == "bottom")
                        {
                            // Horizontally stretched, bottom aligned
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)))");
                        }
                        else if (ctrl.GetAttribute("Align").ToLower() == "middle")
                        {
                            // Horizontally stretched, vertically centered
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)))");
                        }
                        else
                        {
                            throw new Exception("Invalid value '" + ctrl.GetAttribute(
                                    "Align") + "' for Attribute 'Align' of Control '" + ctrl.controlName +
                                "' whose Attribute 'Stretch' is set to '" +
                                ctrl.GetAttribute("Stretch") +
                                "'. Supported values are: top, middle, bottom.");
                        }
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "vertically")
                {
                    if ((!ctrl.HasAttribute("Align"))
                        || (ctrl.HasAttribute("Align") && (ctrl.GetAttribute("Align").ToLower() == "left")))
                    {
                        // Vertically stretched, left aligned (=default)
                        writer.SetControlProperty(
                            ctrl,
                            "Anchor",
                            "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Bottom)))");
                    }
                    else
                    {
                        if (ctrl.GetAttribute("Align").ToLower() == "right")
                        {
                            // Vertically stretched, right aligned
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right) | System.Windows.Forms.AnchorStyles.Bottom)))");
                        }
                        else if (ctrl.GetAttribute("Align").ToLower() == "center")
                        {
                            // Vertically stretched, horizontally centered
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)))");
                        }
                        else
                        {
                            throw new Exception("Invalid value '" + ctrl.GetAttribute(
                                    "Align") + "' for Attribute 'Align' of Control '" + ctrl.controlName +
                                "' whose Attribute 'Stretch' is set to  '" +
                                ctrl.GetAttribute("Stretch") +
                                "'. Supported values are: left, center, right.");
                        }
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "fully")
                {
                    // Fully stretched
                    writer.SetControlProperty(
                        ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right) | System.Windows.Forms.AnchorStyles.Bottom))))");

                    if (ctrl.HasAttribute("Align"))
                    {
                        Console.WriteLine(
                            "WARNING for Control '" + ctrl.controlName +
                            "': Attribute 'Align' gets ignored when Attribute 'Stretch' with value 'fully' is used.");
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "none")
                {
                    // do nothing (here just to avoid throwing the following Exception)
                    Console.WriteLine(
                        "HINT: Attribute 'Stretch' with value 'none' does not affect the layout since this is the default. Control: '" +
                        ctrl.controlName + "'.");
                }
                else
                {
                    throw new Exception("Invalid value for Attribute 'Stretch' of Control '" + ctrl.controlName + "': '" +
                        ctrl.GetAttribute("Stretch") + "'. Supported values are: horizontally, vertically, fully, none.");
                }
            }

            #endregion

            if (ctrl.HasAttribute("Dock"))
            {
                writer.SetControlProperty(ctrl, "Dock");
            }

            if (ctrl.HasAttribute("Visible")
                && (ctrl.GetAttribute("Visible").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "Visible", "false");
            }

            if (ctrl.HasAttribute("Enabled")
                && (ctrl.GetAttribute("Enabled").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "Enabled", "false");
            }
            else if ((ctrl.GetAction() != null) && (TYml2Xml.GetAttribute(ctrl.GetAction().actionNode, "InitiallyEnabled").ToLower() == "false"))
            {
                string ActionEnabling = ctrl.controlName + ".Enabled = false;" + Environment.NewLine;
                writer.Template.AddToCodelet("INITACTIONSTATE", ActionEnabling);
            }

            if (ctrl.HasAttribute("TabStop")
                && (ctrl.GetAttribute("TabStop").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "TabStop", "false");
            }

            if (ctrl.HasAttribute("TabIndex"))
            {
                writer.SetControlProperty(ctrl, "TabIndex", ctrl.GetAttribute("TabIndex"));
            }

            if (ctrl.HasAttribute("BorderStyle"))
            {
                writer.SetControlProperty(ctrl, "BorderStyle", "System.Windows.Forms.BorderStyle." + ctrl.GetAttribute("BorderStyle"));

                if (ctrl.GetAttribute("BorderStyle").ToLower() == "none")
                {
                    writer.SetControlProperty(ctrl, "Margin", "new System.Windows.Forms.Padding(0, 7, 0, 0)");
                }
            }

            if (ctrl.HasAttribute("Padding"))
            {
                writer.SetControlProperty(ctrl, "Padding", "new System.Windows.Forms.Padding(" + ctrl.GetAttribute("Padding") + ")");
            }

            if (ctrl.HasAttribute("Margin"))
            {
                writer.SetControlProperty(ctrl, "Margin", "new System.Windows.Forms.Padding(" + ctrl.GetAttribute("Margin") + ")");
            }

            if (ctrl.HasAttribute("BackColor"))
            {
                writer.SetControlProperty(ctrl, "BackColor", ctrl.GetAttribute("BackColor"));
            }

            if ((ctrl.HasAttribute("Width") || ctrl.HasAttribute("Height")) && (ctrl.GetAttribute("GenerateWithOtherControls") != "yes"))
            {
                if (!ctrl.HasAttribute("Width"))
                {
                    ctrl.SetAttribute("Width", FDefaultWidth.ToString());
                }

                if (!ctrl.HasAttribute("Height"))
                {
                    if ((ctrl.GetAttribute("Dock") == "Left") || (ctrl.GetAttribute("Dock") == "Right"))
                    {
                        // this is useful for AP Payments, left dock list of suppliers
                        writer.SetControlProperty(ctrl, "Width", ctrl.GetAttribute("Width"));
                    }
                    else
                    {
                        ctrl.SetAttribute("Height", FDefaultHeight.ToString());
                    }
                }

                if (ctrl.HasAttribute("Width") && ctrl.HasAttribute("Height"))
                {
                    writer.SetControlProperty(ctrl, "Size", "new System.Drawing.Size(" +
                        ctrl.GetAttribute("Width").ToString() + ", " + ctrl.GetAttribute("Height").ToString() + ")");
                }
            }
            else if (ctrl.HasAttribute("Dock") && (ctrl.GetAttribute("Dock").ToLower() == "fill"))
            {
                if ((ctrl.controlTypePrefix == "pnl") || (ctrl.controlTypePrefix == "grp")
                    || ctrl.controlName.StartsWith("tableLayoutPanel"))
                {
                    // for Mono, no other size information required; AutoSize would make the elements too high
                    // for Windows .Net, we need AutoSize, otherwise the controls have no size at all
                    if (writer.CodeStorage.FTargetWinforms == "net")
                    {
                        writer.SetControlProperty(ctrl, "AutoSize", "true");
                    }
                }
            }
            else if (FAutoSize)
            {
                writer.SetControlProperty(ctrl, "AutoSize", "true");
            }
            else if (ctrl.HasAttribute("Dock") && (ctrl.GetAttribute("Dock").ToLower() != "fill"))
            {
                writer.SetControlProperty(ctrl, "AutoSize", "true");
            }
            else
            {
                writer.SetControlProperty(ctrl, "Size",
                    "new System.Drawing.Size(" + FDefaultWidth.ToString() + ", " + FDefaultHeight.ToString() + ")");
            }

            if (ctrl.HasAttribute("SuppressChangeDetection") && (ctrl.GetAttribute("SuppressChangeDetection").ToLower() == "true"))
            {
                writer.SetControlProperty(ctrl, "Tag", "\"SuppressChangeDetection\"");
            }

            if (ctrl.GetAction() != null)
            {
                string ActionToPerform = ctrl.GetAction().actionName;

                // deal with enabling and disabling of action, affecting the menu item
                if (!writer.Template.FCodelets.Contains("ENABLEDEPENDINGACTIONS_" + ActionToPerform))
                {
                    string ActionEnabling = "";
                    ActionEnabling += "if (e.ActionName == \"" + ActionToPerform + "\")" + Environment.NewLine;
                    ActionEnabling += "{" + Environment.NewLine;
                    ActionEnabling += "    {#ENABLEDEPENDINGACTIONS_" + ActionToPerform + "}" + Environment.NewLine;
                    ActionEnabling += "}" + Environment.NewLine;
                    writer.Template.AddToCodelet("ACTIONENABLING", ActionEnabling);
                }

                AddToActionEnabledEvent(writer, ActionToPerform, ctrl.controlName);

                // deal with action handler
                AssignEventHandlerToControl(writer, ctrl, "Click", ActionToPerform);

                TActionHandler ActionHandler = writer.CodeStorage.FActionList[ActionToPerform];
                SetControlActionProperties(writer, ctrl, ActionHandler);

                if (FCodeStorage.ManualFileExistsAndContains(" " + ActionHandler.actionName.Substring(3) + "(Form AParentForm)"))
                {
                    writer.SetEventHandlerFunction(ActionHandler.actionName.Substring(3), "", ActionHandler.actionName.Substring(
                            3) + "(this);");
                }
            }
            else if (ctrl.HasAttribute("ActionClick"))
            {
                AssignEventHandlerToControl(writer, ctrl, "Click", ctrl.GetAttribute("ActionClick"));
            }
            else if (ctrl.HasAttribute("ActionDoubleClick"))
            {
                AssignEventHandlerToControl(writer, ctrl, "DoubleClick", ctrl.GetAttribute("ActionDoubleClick"));
            }
            else if (ctrl.HasAttribute("ActionOpenScreen"))
            {
                AssignEventHandlerToControl(writer, ctrl, "Click", "OpenScreen" + ctrl.controlName.Substring(ctrl.controlTypePrefix.Length));
                string ActionHandler =
                    "/// auto generated" + Environment.NewLine +
                    "protected void OpenScreen" + ctrl.controlName.Substring(ctrl.controlTypePrefix.Length) + "(object sender, EventArgs e)" +
                    Environment.NewLine +
                    "{" + Environment.NewLine;
                ActionHandler += "    " + ctrl.GetAttribute("ActionOpenScreen") + " frm = new " + ctrl.GetAttribute("ActionOpenScreen") +
                                 "(this);" + Environment.NewLine;

                // Does PropertyForSubScreens fit a property in the new screen? eg LedgerNumber
                if (FCodeStorage.HasAttribute("PropertyForSubScreens"))
                {
                    string propertyName = FCodeStorage.GetAttribute("PropertyForSubScreens");

                    if (FCodeStorage.ImplementationContains(ctrl.GetAttribute("ActionOpenScreen"), " " + propertyName + Environment.NewLine))
                    {
                        ActionHandler += "    frm." + propertyName + " = F" + propertyName + ";" + Environment.NewLine;
                    }
                }

/*                for (string propertyName in FCodeStorage.GetFittingProperties(ctrl.GetAttribute("ActionOpenScreen")))
 *              {
 *                  ActionHandler += "    frm." + propertyName + " = F" + propertyName + ";" + Environment.NewLine;
 *              }
 */
                ActionHandler += "    frm.Show();" + Environment.NewLine;
                ActionHandler += "}" + Environment.NewLine + Environment.NewLine;

                FCodeStorage.FActionHandlers += ActionHandler;
            }

            if (ctrl.HasAttribute("Enabled"))
            {
                AddToActionEnabledEvent(writer, ctrl.GetAttribute("Enabled"), ctrl.controlName);
            }

            if (ctrl.HasAttribute("OnChange"))
            {
                AssignEventHandlerToControl(writer, ctrl,
                    GetEventNameForChangeEvent(),
                    GetEventHandlerTypeForChangeEvent(),
                    ctrl.GetAttribute("OnChange"));
            }

            if (ctrl.HasAttribute("OnLeave"))
            {
                AssignEventHandlerToControl(writer, ctrl,
                    "Leave",
                    "System.EventHandler",
                    ctrl.GetAttribute("OnLeave"));
            }

            if (ctrl.HasAttribute("Tooltip"))
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"" +
                    ctrl.GetAttribute("Tooltip") +
                    "\"));" + Environment.NewLine);
            }

            if (ctrl.HasAttribute("PartnerShortNameLookup"))
            {
                LinkControlPartnerShortNameLookup(writer, ctrl);
            }
            else if (ctrl.HasAttribute("DataField"))
            {
                string dataField = ctrl.GetAttribute("DataField");
                bool IsDetailNotMaster;

                TTableField field = TDataBinding.GetTableField(ctrl, dataField, out IsDetailNotMaster, true);

                LinkControlDataField(writer, ctrl, field, IsDetailNotMaster);
            }
            else if (writer.CodeStorage.HasAttribute("MasterTable") || writer.CodeStorage.HasAttribute("DetailTable"))
            {
                //if (ctrl.controlTypePrefix != "lbl" && ctrl.controlTypePrefix != "pnl" && ctrl.controlTypePrefix != "grp" &&
                if (!((this is LabelGenerator) || (this is LinkLabelGenerator)))
                {
                    bool IsDetailNotMaster;
                    TTableField field = TDataBinding.GetTableField(ctrl, ctrl.controlName.Substring(
                            ctrl.controlTypePrefix.Length), out IsDetailNotMaster, false);

                    if (field != null)
                    {
                        LinkControlDataField(writer, ctrl, field, IsDetailNotMaster);
                    }
                }
            }
            else if (ctrl.controlTypePrefix == "uco")
            {
                writer.Template.AddToCodelet("SAVEDATA", ctrl.controlName + ".GetDataFromControls();" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY",
                    ctrl.controlName + ".SetPrimaryKeyReadOnly(AReadOnly);" + Environment.NewLine);
            }
            else if (ctrl.HasAttribute("DynamicControlType"))
            {
                writer.Template.AddToCodelet("SAVEDATA", "if(FUco" + ctrl.controlName.Substring(
                        3) + " != null)" + Environment.NewLine + "{" + Environment.NewLine +
                    "    FUco" + ctrl.controlName.Substring(3) + ".GetDataFromControls();" + Environment.NewLine + "}" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY", "if(FUco" + ctrl.controlName.Substring(
                        3) + " != null)" + Environment.NewLine + "{" + Environment.NewLine +
                    "    FUco" + ctrl.controlName.Substring(
                        3) + ".SetPrimaryKeyReadOnly(AReadOnly);" + Environment.NewLine + "}" + Environment.NewLine);
            }

            // the readonly property eg of Textbox still allows tooltips and copy to clipboard, which enable=false would not allow
            if (TYml2Xml.HasAttribute(ctrl.xmlNode, "ReadOnly")
                && (TYml2Xml.GetAttribute(ctrl.xmlNode, "ReadOnly").ToLower() == "true"))
            {
                if (FHasReadOnlyProperty)
                {
                    writer.SetControlProperty(ctrl,
                        "ReadOnly",
                        "true");
                    writer.SetControlProperty(ctrl,
                        "TabStop",
                        "false");
                }
                else
                {
                    writer.SetControlProperty(ctrl,
                        "Enabled",
                        "false");
                }
            }

            return writer.Template;
        }

        /// <summary>
        /// this is useful for radiobuttons or checkboxes which have other controls that depend on them
        /// </summary>
        /// <param name="ctrl"></param>
        protected void CheckForOtherControls(TControlDef ctrl)
        {
            XmlNode Controls = TXMLParser.GetChild(ctrl.xmlNode, "Controls");

            if (Controls != null)
            {
                StringCollection childControls = TYml2Xml.GetElements(Controls);

                // this is a checkbox that enables another control or a group of controls
                ctrl.SetAttribute("GenerateWithOtherControls", "yes");

                if (childControls.Count == 1)
                {
                    TControlDef ChildCtrl = ctrl.FCodeStorage.GetControl(childControls[0]);
                    ChildCtrl.parentName = ctrl.controlName;

                    // use the label of the child control
                    if (ChildCtrl.HasAttribute("Label"))
                    {
                        ctrl.Label = ChildCtrl.Label;
                    }
                }
                else
                {
                    foreach (string child in childControls)
                    {
                        TControlDef ChildCtrl = ctrl.FCodeStorage.GetControl(child);

                        if (ChildCtrl == null)
                        {
                            throw new Exception("cannot find control " + child + " which should belong to " + ctrl.controlName);
                        }

                        ChildCtrl.parentName = ctrl.controlName;
                    }
                }
            }
        }

        /// <summary>
        /// fetch the partner short name from the server;
        /// this control is readonly, therefore we don't need statusbar help
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        private void LinkControlPartnerShortNameLookup(TFormWriter writer, TControlDef ctrl)
        {
            string PartnerShortNameLookup = ctrl.GetAttribute("PartnerShortNameLookup");
            bool IsDetailNotMaster;

            TTableField field = TDataBinding.GetTableField(ctrl, PartnerShortNameLookup, out IsDetailNotMaster, true);

            string showData = "TPartnerClass partnerClass;" + Environment.NewLine;
            string RowName = "FMainDS." + TTable.NiceTableName(field.strTableName) + "[0]";

            if ((TTable.NiceTableName(field.strTableName) == writer.CodeStorage.GetAttribute("DetailTable"))
                || (TTable.NiceTableName(field.strTableName) == writer.CodeStorage.GetAttribute("MasterTable")))
            {
                RowName = "ARow";
            }

            showData += "string partnerShortName;" + Environment.NewLine;
            showData += "TRemote.MPartner.Partner.ServerLookups.GetPartnerShortName(" + Environment.NewLine;
            showData += "    " + RowName + "." + TTable.NiceFieldName(field.strName) + "," +
                        Environment.NewLine;
            showData += "    out partnerShortName," + Environment.NewLine;
            showData += "    out partnerClass);" + Environment.NewLine;
            showData += ctrl.controlName + ".Text = partnerShortName;" + Environment.NewLine;

            writer.Template.AddToCodelet("SHOWDATA", showData);
        }

        private void LinkControlDataField(TFormWriter writer, TControlDef ctrl, TTableField AField, bool AIsDetailNotMaster)
        {
            if (AField == null)
            {
                return;
            }

            string tablename = TTable.NiceTableName(AField.strTableName);
            string fieldname = TTable.NiceFieldName(AField);
            string RowName = "FMainDS." + tablename + "[0]";
            string TestForNullTable = "FMainDS." + tablename;

            if ((tablename == writer.CodeStorage.GetAttribute("DetailTable")) || (tablename == writer.CodeStorage.GetAttribute("MasterTable")))
            {
                RowName = "ARow";
                TestForNullTable = "";
            }

            string targetCodelet = "SHOWDATA";

            if (tablename == writer.CodeStorage.GetAttribute("DetailTable"))
            {
                targetCodelet = "SHOWDETAILS";
            }

            ProcessTemplate snippetShowData = writer.Template.GetSnippet("SHOWDATAFORCOLUMN");

            snippetShowData.SetCodelet("CANBENULL", !AField.bNotNull ? "yes" : "");
            snippetShowData.SetCodelet("DETERMINECONTROLISNULL", this.GetControlValue(ctrl, null));
            snippetShowData.SetCodelet("NOTDEFAULTTABLE", TestForNullTable);
            snippetShowData.SetCodelet("ROW", RowName);
            snippetShowData.SetCodelet("COLUMNNAME", fieldname);
            snippetShowData.SetCodelet("SETNULLVALUE", this.AssignValue(ctrl, null, null));
            snippetShowData.SetCodelet("SETCONTROLVALUE", this.AssignValue(ctrl, RowName + "." + fieldname, AField.GetDotNetType()));

            writer.Template.InsertSnippet(targetCodelet, snippetShowData);

            if (AField.bPartOfPrimKey)
            {
                // check if the current row is new; then allow changing the primary key; otherwise make the control readonly
                writer.Template.AddToCodelet(targetCodelet, ctrl.controlName + "." + (FHasReadOnlyProperty ? "ReadOnly" : "Enabled") + " = " +
                    "(" + RowName + ".RowState " + (FHasReadOnlyProperty ? "!=" : "==") + " DataRowState.Added);" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY",
                    ctrl.controlName + "." + (FHasReadOnlyProperty ? "ReadOnly" : "Enabled") + " = AReadOnly;" + Environment.NewLine);
            }

            if (ctrl.GetAttribute("ReadOnly").ToLower() != "true")
            {
                targetCodelet = targetCodelet.Replace("SHOW", "SAVE");

                ProcessTemplate snippetGetData = writer.Template.GetSnippet("GETDATAFORCOLUMNTHATCANBENULL");

                snippetGetData.SetCodelet("CANBENULL", !AField.bNotNull && (this.GetControlValue(ctrl, null) != null) ? "yes" : "");
                snippetGetData.SetCodelet("NOTDEFAULTTABLE", TestForNullTable);
                snippetGetData.SetCodelet("DETERMINECONTROLISNULL", this.GetControlValue(ctrl, null));
                snippetGetData.SetCodelet("ROW", RowName);
                snippetGetData.SetCodelet("COLUMNNAME", fieldname);
                snippetGetData.SetCodelet("CONTROLVALUE", this.GetControlValue(ctrl, AField.GetDotNetType()));

                writer.Template.InsertSnippet(targetCodelet, snippetGetData);
            }

            // setstatusbar tooltips for datafields, with getstring plus value from petra.xml
            string helpText = AField.strHelp;

            if (helpText.Length == 0)
            {
                helpText = AField.strDescription;
            }

            if (helpText.Length > 0)
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"" +
                    helpText.Replace("\"", "\\\"") +  // properly escape double quotation marks
                    "\"));" + Environment.NewLine);
            }
        }

        /// <summary>
        /// Sets the properties of a control which are defined under "Actions:" in the .yaml file
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        /// <param name="AActionHandler"></param>
        public virtual void SetControlActionProperties(TFormWriter writer, TControlDef ctrl, TActionHandler AActionHandler)
        {
            if (AActionHandler.actionImage.Length > 0)
            {
                /* Get the name of the image for the toolbar button
                 * and put it into the resources.
                 * The images must be in the directory specified by the ResourceDir command line parameter
                 */
                writer.SetControlProperty(ctrl, "Image",
                    "((System.Drawing.Bitmap)resources" + ctrl.controlType + ".GetObject(\"" + ctrl.controlName + ".Glyph\"))");
                writer.AddImageToResource(ctrl.controlName, AActionHandler.actionImage, "Bitmap");
            }

            if (AActionHandler.actionTooltip.Length > 0)
            {
                writer.SetControlProperty(ctrl, "ToolTipText", "\"" + AActionHandler.actionTooltip + "\"");
            }
        }

        /// <summary>
        /// write code for on change event
        /// </summary>
        public virtual void OnChangeDataType(TFormWriter writer, XmlNode curNode)
        {
            OnChangeDataType(writer, curNode, curNode.Name);
        }

        /// <summary>
        /// write code for on change event
        /// </summary>
        public virtual void OnChangeDataType(TFormWriter writer, XmlNode curNode, string controlName)
        {
            // the selection of this control triggers the available options in other controls
            if (TYml2Xml.HasAttribute(curNode, "OnChangeDataType"))
            {
                writer.Template.AddToCodelet("CONTROLINITIALISATION",
                    "this." + controlName + ".Leave += new EventHandler(this." + StringHelper.UpperCamelCase(controlName,
                        ",",
                        false,
                        false) + "_SelectionChangeCommitted);" + Environment.NewLine +
                    "this." + controlName + ".SelectionChangeCommitted += new EventHandler(this." +
                    StringHelper.UpperCamelCase(controlName, ",", false, false) + "_SelectionChangeCommitted);" + Environment.NewLine);
                writer.CodeStorage.FEventHandlersImplementation +=
                    "private void " +
                    StringHelper.UpperCamelCase(controlName, ",", false,
                        false) + "_SelectionChangeCommitted(System.Object sender, System.EventArgs e)" + Environment.NewLine +
                    "{" + Environment.NewLine +
                    "  " +
                    StringHelper.UpperCamelCase(controlName, ",", false,
                        false) + "_Initialise(" + controlName + ".GetSelected" + TYml2Xml.GetAttribute(
                        curNode,
                        "OnChangeDataType") + "());" + Environment.NewLine +
                    "}" + Environment.NewLine + Environment.NewLine;
                writer.CodeStorage.FEventHandlersImplementation +=
                    "private void " + StringHelper.UpperCamelCase(controlName, ",", false, false) + "_Initialise(" + TYml2Xml.GetAttribute(curNode,
                        "OnChangeDataType") + " AParam)" + Environment.NewLine +
                    "{" + Environment.NewLine +
                    "  Int32 Index;" + Environment.NewLine +
                    "  Index = this." + controlName + ".Find" +
                    TYml2Xml.GetAttribute(curNode, "OnChangeDataType") + "InComboBox(AParam);" + Environment.NewLine +
                    "  if ((Index >= 0) && (Index < this." + controlName + ".Items.Count) && (Index != this." + controlName + ".SelectedIndex)) " +
                    Environment.NewLine +
                    "  {" + Environment.NewLine +
                    "    this." + controlName + ".SelectedIndex = Index;" + Environment.NewLine +
                    "  }" + Environment.NewLine +
                    "  {#INITIALISE_" + controlName + "}" + Environment.NewLine +
                    "}" + Environment.NewLine + Environment.NewLine;
            }
        }

        /// e.g. used for controls on Reports (readparameter, etc)
        public virtual void ApplyDerivedFunctionality(TFormWriter writer, XmlNode curNode)
        {
        }
    }

    /// <summary>
    /// Providers are not added to any control; they don't have a name, size of position
    /// </summary>
    public class ProviderGenerator : TControlGenerator
    {
        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="APrefix"></param>
        /// <param name="AType"></param>
        public ProviderGenerator(string APrefix, System.Type AType)
            : base(APrefix, AType)
        {
            FLocation = false;
            FGenerateLabel = false;
            FAddControlToContainer = false;
        }

        /// <summary>write the code for the designer file where the properties of the control are written</summary>
        public override ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef ctrl)
        {
            // don't call base, because it should not have size, location, or name
            writer.Template.AddToCodelet("CONTROLINITIALISATION",
                "//" + Environment.NewLine + "// " + ctrl.controlName + Environment.NewLine + "//" + Environment.NewLine);

            return writer.FTemplate;
        }
    }

    /// <summary>
    /// base class for generators for container controls
    /// </summary>
    public class ContainerGenerator : TControlGenerator
    {
        List <TControlDef>FChildren = new List <TControlDef>();
        bool FCreateControlsAddStatements = true;

        /// <summary>
        /// the children of this container, ie. controls that live in this container
        /// </summary>
        public List <TControlDef>Children
        {
            get
            {
                return FChildren;
            }
        }

        /// <summary>
        /// code for creating the controls and adding them to the container
        /// </summary>
        public bool CreateControlsAddStatements
        {
            get
            {
                return FCreateControlsAddStatements;
            }

            set
            {
                FCreateControlsAddStatements = value;
            }
        }

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="prefix"></param>
        /// <param name="type"></param>
        public ContainerGenerator(string prefix, System.Type type)
            : base(prefix, type)
        {
        }

        /// constructor
        public ContainerGenerator(string prefix, System.String type)
            : base(prefix, type)
        {
        }

        /// <summary>
        /// declaring the container control
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        public override void GenerateDeclaration(TFormWriter writer, TControlDef ctrl)
        {
            base.GenerateDeclaration(writer, ctrl);
            writer.AddContainer(ctrl.controlName);
        }

        /// <summary>write the code for the designer file where the properties of the control are written</summary>
        public override ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef container)
        {
            FChildren = new List <TControlDef>();

            // add all the children
            foreach (TControlDef child in container.FCodeStorage.FSortedControlList.Values)
            {
                if (child.parentName == container.controlName)
                {
                    FChildren.Add(child);
                }
            }

            FChildren.Sort(new CtrlItemOrderComparer());

            base.SetControlProperties(writer, container);

            if (FCreateControlsAddStatements)
            {
                foreach (TControlDef child in FChildren)
                {
                    writer.CallControlFunction(container.controlName,
                        "Controls.Add(this." +
                        child.controlName + ")");
                }
            }

            return writer.FTemplate;
        }
    }

    /// <summary>
    /// generator for the toolstrip
    /// </summary>
    public class ToolStripGenerator : TControlGenerator
    {
        /// <summary>
        /// where to dock
        /// </summary>
        public string FDocking = "Top";

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="prefix"></param>
        /// <param name="AType"></param>
        public ToolStripGenerator(string prefix, System.Type AType)
            : base(prefix, AType)
        {
            FGenerateLabel = false;
            FLocation = false;
            FDefaultHeight = 24;
            FDefaultWidth = 10;
        }

        /// <summary>
        /// declare the control
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        public override void GenerateDeclaration(TFormWriter writer, TControlDef ctrl)
        {
            base.GenerateDeclaration(writer, ctrl);
            writer.AddContainer(ctrl.controlName);
        }

        /// <summary>
        /// get the controls that belong to the toolstrip
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="container"></param>
        /// <returns></returns>
        public static string GetListOfChildren(TFormWriter writer, TControlDef container)
        {
            // add all the children
            string addChildren = "";

            // TODO add Container elements in statusbar
            if (container.controlName.StartsWith("stb"))
            {
                return addChildren;
            }

            List <XmlNode>childrenlist;

            if (TYml2Xml.GetChild(container.xmlNode, "Controls") != null)
            {
                // this is for generated toolbar, eg. for the PrintPreviewControl
                StringCollection childrenNames = TYml2Xml.GetElements(container.xmlNode, "Controls");
                childrenlist = new List <XmlNode>();

                foreach (string name in childrenNames)
                {
                    childrenlist.Add(container.xmlNode.OwnerDocument.CreateElement(name));
                }
            }
            else
            {
                // usually, the toolbar buttons are direct children of the toolbar control
                childrenlist = TYml2Xml.GetChildren(container.xmlNode, true);
            }

            //Console.WriteLine("Container: " + container.controlName);
            foreach (XmlNode child in childrenlist)
            {
                // Console.WriteLine("Child: " + child.Name);
                if (addChildren.Length > 0)
                {
                    addChildren += "," + Environment.NewLine + "            ";
                }

                /* Get unique name if we need it
                 * at the moment we need it only for menu separators
                 */
                String UniqueChildName = child.Name;
                TControlDef ControlDefChild = container.FCodeStorage.GetControl(child.Name);

                if (ControlDefChild == null)
                {
                    UniqueChildName = TYml2Xml.GetAttribute(child, "UniqueName");
                    ControlDefChild = container.FCodeStorage.GetControl(UniqueChildName);
                }

                addChildren = addChildren + UniqueChildName;                 //child.Name; //controlName;

                if (ControlDefChild != null)
                {
                    IControlGenerator ctrlGenerator = writer.FindControlGenerator(ControlDefChild);

                    // add control itself
                    if (ctrlGenerator != null)
                    {
                        ctrlGenerator.GenerateDeclaration(writer, ControlDefChild);
                        ctrlGenerator.SetControlProperties(writer, ControlDefChild);
                    }
                }
            }

            return addChildren;
        }

        /// <summary>write the code for the designer file where the properties of the control are written</summary>
        public override ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef container)
        {
            string controlName = container.controlName;

            // add all the children
            string addChildren = GetListOfChildren(writer, container);

            container.SetAttribute("Dock", FDocking);
            base.SetControlProperties(writer, container);

            if (addChildren.Length > 0)
            {
                writer.CallControlFunction(controlName,
                    "Items.AddRange(new System.Windows.Forms.ToolStripItem[] {" + Environment.NewLine +
                    "               " + addChildren +
                    "})");
            }

            // todo: location?
            // todo: event handler

            /*
             * this.menuStrip1.Dock = System.Windows.Forms.DockStyle.None;
             * this.menuStrip1.Items.AddRange(new System.Windows.Forms.ToolStripItem[] {
             * this.toolStripMenuItem1});
             * this.menuStrip1.Location = new System.Drawing.Point(0, 0);
             * this.menuStrip1.Name = "menuStrip1";
             * this.menuStrip1.Size = new System.Drawing.Size(138, 24);
             * this.menuStrip1.TabIndex = 1;
             * this.menuStrip1.Text = "menuStrip1";
             * this.menuStrip1.ItemClicked += new System.Windows.Forms.ToolStripItemClickedEventHandler(this.MenuStrip1ItemClicked);
             */

            return writer.FTemplate;
        }
    }
}