<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ict.Common.Data</name>
    </assembly>
    <members>
        <member name="T:Ict.Common.Data.TTypedDataAccess">
            <summary>
            This is the base class for the data access store.
            It mainly contains static methods.
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.MODIFICATION_ID">
            name of the column used for tracking changes, one ID per change
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.MODIFIED_BY">
            <summary>
            who has last modified the row
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.MODIFIED_DATE">
            <summary>
            when was the last change to the row
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.CREATED_BY">
            <summary>
            who has originally created this row
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.CREATED_DATE">
            <summary>
            when was this row originally created
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.MODIFICATION_ID_DELETEDROW_INDICATOR">
            <summary>
            indicates whether a row has been deleted
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.NoDefaultColumn(System.String)">
             <summary>
             This function returns true if the column name is not one of the special columns, that
             are written automatically: modified date and by, created date and by, modification id
            
             </summary>
             <returns>true if this is no special auto column</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetNextModificationID(Ict.Common.DB.TDBTransaction)">
             <summary>
             This function returns the next available modification ID.
             It uses the next-value of the sequences seq_modification1 and seq_modification2
             (first counting up seq_modification1, then increasing once seq_modification2,
             and cycling through seq_modification1 again)
             The string is made up by the two values of the sequences, formatted as Hex numbers, and
             separated by a semicolon.
            
             </summary>
             <returns>the next modification ID</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetStoredModification(System.Int16,System.String[],System.Int32[],System.Data.DataRow,Ict.Common.DB.TDBTransaction,System.String@,System.String@,System.DateTime@)">
             <summary>
             This function returns the modification details of a row
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.InsertRow(System.Int16,System.Data.DataRow@,Ict.Common.DB.TDBTransaction,System.String)">
             <summary>
             This function is called by the DataStore (SubmitChanges)
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.UpdateRow(System.Int16,System.Data.DataRow@,Ict.Common.DB.TDBTransaction,System.String)">
             <summary>
             This function is called by the DataStore (SubmitChanges)
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.DeleteRow(System.Int16,System.Data.DataRow,Ict.Common.DB.TDBTransaction)">
             <summary>
             This function is called by the DataStore (SubmitChanges)
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateSelectClause(System.Collections.Specialized.StringCollection,System.Int16)">
            <summary>
            This function expects a StringCollection that can be filled, empty or nil.
            It also needs the list of the primary key columns, because otherwise the returned row will fail the constraints.
            It will return a proper Select Clause.
            </summary>
            <returns>the Select Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateSelectClauseLong(System.String,System.Collections.Specialized.StringCollection,System.Int16)">
            <summary>
            This function expects a StringCollection that can be filled, empty or nil.
            It also needs the list of the primary key columns, because otherwise the returned row will fail the constraints.
            It will prefix all fields with the given tablename. needed for selecting from join statements.
            It will return a proper Select Clause.
            If a field has already a dot in the name, the ATablename is not put before it: That way you can do SUM(PUB_table.p_something).
            </summary>
            <returns>the Select Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClause(System.String[],System.Data.DataRow,System.Collections.Specialized.StringCollection)">
            <summary>
            This function expects an empty table that contains all existing columns,
            and a datarow that has a string or an empty value for each column.
            It will return a Where clause, using the given values.
            </summary>
            <param name="AColumnNames">the column names</param>
            <param name="ADataRow">the data row with the the columns for the where clause</param>
            <param name="ATemplateOperators">Every template field can have an operator; the default version always used = or LIKE</param>
            <returns>the Where Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClause(System.String[],System.Data.DataRow)">
            <summary>
            This function expects an empty table that contains all existing columns,
            and a datarow that has a string or an empty value for each column.
            It will return a Where clause, using the given values.
            </summary>
            <returns>the Where Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClause(System.String[],Ict.Common.TSearchCriteria[],System.Collections.Specialized.StringCollection)">
            <summary>
            This function expects an empty table that contains all existing columns,
            and search criteria.
            It will return a Where clause, using the given values.
            </summary>
            <param name="AColumnNames">the column names</param>
            <param name="ASearchCriteria"></param>
            <param name="ATemplateOperators">Every template field can have an operator; the default version always used = or LIKE</param>
            <returns>the Where Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClause(System.String[],Ict.Common.TSearchCriteria[])">
            <summary>
            This function expects an empty table that contains all existing columns,
            and a datarow that has a string or an empty value for each column.
            It will return a Where clause, using the given values.
            </summary>
            <returns>the Where Clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClause(System.String[])">
            <summary>
            this function generates a simple where clause with the given fieldnames
            </summary>
            <param name="AFieldNames"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClauseFromPrimaryKey(System.Int16)">
            <summary>
            this function generates a where clause for the primary key of the given table
            </summary>
            <param name="ATableId"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClauseLong(System.String,System.Int16,System.Data.DataRow,System.Collections.Specialized.StringCollection)">
             <summary>
             This function expects a string list of all existing columns,
             and a datarow that has a value or an empty value for each column.
             It will return a Where clause, using the given values.
             It does not contain the WHERE keyword.
             It uses the long form, table.fieldname
            
             </summary>
             <param name="ATableName">the table that the where clause is generated for</param>
             <param name="ATableId">id of the table to get the list of all columns of that table</param>
             <param name="ADataRow">contains the values for the where clause</param>
             <param name="ATemplateOperators">Every template field can have an operator; the default version always used = or LIKE</param>
             <returns>the Where Clause
             </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClauseLong(System.String,Ict.Common.TSearchCriteria[])">
             <summary>
             This function expects a string list of all existing columns,
             and a criteria list of values to search for.
             It will return a Where clause, using the given values.
             It does not contain the WHERE keyword.
             It uses the long form, table.fieldname
            
             </summary>
             <param name="ATableName">the table that the where clause is generated for</param>
             <param name="ASearchCriteria"></param>
             <returns>the Where Clause
             </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateWhereClauseLong(System.String,System.Int16,System.Data.DataRow)">
             <summary>
             This function expects a string array with the names of all existing columns,
             and a datarow that has a value or an empty value for each column.
             It will return a Where clause, using the given values.
             It does not contain the WHERE keyword.
             It uses the long form, table.fieldname
            
             </summary>
             <param name="ATableName">the table that the where clause is generated for</param>
             <param name="ATableId">id of the table to get the list of all columns of that table</param>
             <param name="ADataRow">contains the values for the where clause</param>
             <returns>the Where Clause
             </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateOrderByClause(System.Collections.Specialized.StringCollection)">
            <summary>
            This function expects a list of string, where the first string is either "order by" or "group by",
            and the rest of the string is e.g. "p_partner.p_partner_key_n ASC"
            It will return the appropriate part of the sql query
            </summary>
            <param name="AOrderBy">String list with instructions how to order or group the result</param>
            <returns>the order by / group by clause
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CreateOdbcParameter(System.Int16,System.Int32,System.Object)">
             <summary>
             This function creates an odbc parameter with the correct type, based on the obj which comes from a DataRow
            
             </summary>
             <param name="ATableId">Table that we are operating on</param>
             <param name="AColumnNr">which column should the parameter be generated for</param>
             <param name="obj">the value that needs to be converted to OdbcParameter</param>
             <returns>the Odbc parameter</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CreateOdbcParameterArrayFromKey(System.Int16,System.Int32[],System.Object[])">
            <summary>
            create the odbc parameters for the the given key, with the actual values
            </summary>
            <param name="ATableId"></param>
            <param name="AKeyColumns"></param>
            <param name="AKeyValues"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CreateOdbcParameterArrayFromPrimaryKey(System.Int16,System.Object[])">
            <summary>
            create the odbc parameters for the primary key, with the actual values
            </summary>
            <param name="ATableId"></param>
            <param name="APrimaryKeyValues"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetSafeValue(System.Data.DataRow,System.Int32,System.Data.DataRowVersion)">
             <summary>
             This function returns either a valid object or System.DBNull;
             this is necessary because mono sometimes has a nil pointer in the DataRow for the original version etc.
            
             </summary>
             <returns>either a valid object or System.DBNull</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetSafeValue(System.Data.DataRow,System.String,System.Data.DataRowVersion)">
             <summary>
             This function returns either a valid object or System.DBNull;
             this is necessary because mono sometimes has a nil pointer in the DataRow for the original version etc.
            
             </summary>
             <returns>either a valid object or System.DBNull</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.NotEquals(System.Data.DataRow,System.Int32,System.Object@)">
             <summary>
             Compare the original and the current value of a column in a datarow.
             Make sure some mono specific troubles are worked around.
            
             </summary>
             <returns>result of comparison</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForWhereClause(System.Int16,System.Data.DataRow)">
            <summary>
            This function provides the actual parameters for the GenerateWhereClause
            uses only the values that are not DBNULL
            </summary>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForWhereClauseWithPrimaryKey(System.Int16,System.Data.DataRow)">
            <summary>
            This function provides the actual parameters for the GenerateWhereClause
            uses only the values that are not DBNULL
            </summary>
            <param name="ADataRow">values that are used as parameters</param>
            <param name="ATableId">identifier of the table to get the primary key from it</param>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForWhereClause(System.Int16,Ict.Common.TSearchCriteria[])">
            <summary>
            This function provides the actual parameters for the GenerateWhereClause
            </summary>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForInsertClause(System.Int16,System.Data.DataRow@,System.Int32,Ict.Common.DB.TDBTransaction,System.String)">
            <summary>
            This function provides the actual parameters for the GenerateInsertClause
            uses only the values that are not DBNULL
            adds the next modification ID
            </summary>
            <param name="ATableId"></param>
            <param name="ADataRow">values that are used as parameters</param>
            <param name="ANumberDBColumns">the number of columns of this row that should be stored in the database; that allows some columns to be added temporarily, e.g. PPartnerLocation.BestAddress in PartnerEdit Dataset</param>
            <param name="ATransaction">need a transaction for getting the next modification id</param>
            <param name="ACurrentUser">for setting modified by</param>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForUpdateClause(System.Int16,System.Data.DataRow@,System.Int32[],System.Int32,Ict.Common.DB.TDBTransaction,System.String)">
            <summary>
            This function provides the actual parameters for the GenerateUpdateClause
            uses only the values that are changed (comparing the current and the original version of the row)
            </summary>
            <param name="ATableId"></param>
            <param name="ADataRow">values that are used as parameters</param>
            <param name="APrimaryKeyColumnOrd">can be empty; is needed for the UPDATE WHERE statement; it has the order numbers of the columns that make up the primary key</param>
            <param name="ANumberDBColumns">the number of columns of this row that should be stored in the database; that allows some columns to be added temporarily, e.g. PPartnerLocation.BestAddress in PartnerEdit Dataset</param>
            <param name="ATransaction">required for increasing the modification id</param>
            <param name="ACurrentUser">for setting modified by</param>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GetParametersForDeleteClause(System.Int16,System.Data.DataRow,System.Int32[])">
            <summary>
            This function provides the actual parameters for the GenerateDeleteClause
            it uses the OriginalVersion of the primary key values
            </summary>
            <param name="ATableId"></param>
            <param name="ADataRow">values that are used as parameters</param>
            <param name="APrimaryKeyColumnOrd">has the order numbers of the columns that make up the primary key</param>
            <returns>an array of OdbcParameters
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateInsertClause(System.String,System.String[],System.Data.DataRow)">
             <summary>
             This function expects an empty table that contains all existing columns,
             and a datarow that has a value or an empty value for each column.
             It will return a complete INSERT Clause.
            
             </summary>
             <returns>the INSERT statement
             </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateUpdateClause(System.String,System.String[],System.Data.DataRow,System.Int32[])">
             <summary>
             This function expects an empty table that contains all existing columns,
             and a datarow that has a value or an empty value for each column.
            
             </summary>
             <returns>the UPDATE statement
             </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.GenerateDeleteClause(System.String,System.String[],System.Data.DataRow,System.Int32[])">
            <summary>
            This function will build a DELETE statement using the DataRowVersion.Original values of the primary key columns
            </summary>
            <returns>the DELETE statement
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadByPrimaryKey(System.Int16,System.Data.DataSet,System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load data row by primary key into a dataset
            </summary>
            <param name="ATableId"></param>
            <param name="ADataSet"></param>
            <param name="APrimaryKeyValues"></param>
            <param name="AFieldList"></param>
            <param name="ATransaction"></param>
            <param name="AOrderBy"></param>
            <param name="AStartRecord"></param>
            <param name="AMaxRecords"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadByPrimaryKey(System.Int16,Ict.Common.Data.TTypedDataTable,System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            different version for data table
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadByUniqueKey(System.Int16,System.Data.DataSet,System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load data row by unique key into a dataset
            </summary>
            <param name="ATableId"></param>
            <param name="ADataSet"></param>
            <param name="AUniqueKeyValues"></param>
            <param name="AFieldList"></param>
            <param name="ATransaction"></param>
            <param name="AOrderBy"></param>
            <param name="AStartRecord"></param>
            <param name="AMaxRecords"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadByUniqueKey(System.Int16,Ict.Common.Data.TTypedDataTable,System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            different version for data table
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,System.Data.DataSet,System.String[],System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load data for the current table via a foreign key, eg. load all extracts created by user x
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,Ict.Common.Data.TTypedDataTable,System.String[],System.Object[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load data for the current table via a foreign key, eg. load all extracts created by user x
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,System.Data.DataSet,System.String[],System.Data.DataRow,System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            Load via other table, using template values
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,Ict.Common.Data.TTypedDataTable,System.String[],System.Data.DataRow,System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            Load via other table, using template values
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,System.Data.DataSet,System.String[],Ict.Common.TSearchCriteria[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            Load via other table, using template values
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadViaForeignKey(System.Int16,System.Int16,Ict.Common.Data.TTypedDataTable,System.String[],Ict.Common.TSearchCriteria[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            Load via other table, using template values
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CountViaForeignKey(System.Int16,System.Int16,System.String[],System.Object[],Ict.Common.DB.TDBTransaction)">
            count the rows by the values of a foreign key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CountViaForeignKey(System.Int16,System.Int16,System.String[],System.Data.DataRow,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction)">
            count the rows by the values of a foreign key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.CountViaForeignKey(System.Int16,System.Int16,System.String[],Ict.Common.TSearchCriteria[],Ict.Common.DB.TDBTransaction)">
            count the rows by the values of a foreign key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.DeleteByPrimaryKey(System.Int16,System.Object[],Ict.Common.DB.TDBTransaction)">
            <summary>
            delete by primary key values
            </summary>
            <param name="ATableId"></param>
            <param name="APrimaryKeyValues"></param>
            <param name="ATransaction"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.Exists(System.Int16,System.Object[],Ict.Common.DB.TDBTransaction)">
            <summary>
            check if row exists with the primary key
            </summary>
            <param name="ATableId"></param>
            <param name="APrimaryKeyValues"></param>
            <param name="ATransaction"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadUsingTemplate(System.Int16,System.Data.DataSet,Ict.Common.TSearchCriteria[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            loads all rows matching certain search criteria into a dataset
            </summary>
            <param name="ATableID">specify which typed table is used</param>
            <param name="ADataSet">the result will be added to this dataset</param>
            <param name="ASearchCriteria"></param>
            <param name="AFieldList">fields to load from the database table</param>
            <param name="ATransaction"></param>
            <param name="AOrderBy"></param>
            <param name="AStartRecord"></param>
            <param name="AMaxRecords"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadUsingTemplate(System.Int16,Ict.Common.Data.TTypedDataTable,Ict.Common.TSearchCriteria[],System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            loads all rows matching certain search criteria into a typed data table
            </summary>
            <param name="ATableID">specify which typed table is used</param>
            <param name="ATypedTableToLoad">pre condition: has to have an object of the typed table</param>
            <param name="ASearchCriteria"></param>
            <param name="AFieldList"></param>
            <param name="ATransaction"></param>
            <param name="AOrderBy"></param>
            <param name="AStartRecord"></param>
            <param name="AMaxRecords"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadUsingTemplate(System.Int16,System.Data.DataSet,System.Data.DataRow,System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load using a template row
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.LoadUsingTemplate(System.Int16,Ict.Common.Data.TTypedDataTable,System.Data.DataRow,System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction,System.Collections.Specialized.StringCollection,System.Int32,System.Int32)">
            <summary>
            load using a template row
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.DeleteUsingTemplate(System.Int16,System.Data.DataRow,System.Collections.Specialized.StringCollection,Ict.Common.DB.TDBTransaction)">
            <summary>
            delete all rows matching the given row
            </summary>
            <param name="ATableId"></param>
            <param name="ATemplateRow"></param>
            <param name="ATemplateOperators"></param>
            <param name="ATransaction"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.DeleteUsingTemplate(System.Int16,Ict.Common.TSearchCriteria[],Ict.Common.DB.TDBTransaction)">
            <summary>
            delete all rows matching the search criteria
            </summary>
            <param name="ATableId">specify which typed table is used</param>
            <param name="ASearchCriteria"></param>
            <param name="ATransaction"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.SubmitChanges(Ict.Common.Data.TTypedDataTable,Ict.Common.DB.TDBTransaction,Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations,Ict.Common.Verification.TVerificationResultCollection@,System.String,System.String,System.String)">
            <summary>
            submit those rows in the table that have been modified or created or deleted
            </summary>
            <param name="ATable"></param>
            <param name="ATransaction"></param>
            <param name="ASelectedOperations"></param>
            <param name="AVerificationResult"></param>
            <param name="AUserId">the current user, for auditing</param>
            <param name="ASequenceName"></param>
            <param name="ASequenceField"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.SubmitChanges(Ict.Common.Data.TTypedDataTable,Ict.Common.DB.TDBTransaction,Ict.Common.Verification.TVerificationResultCollection@,System.String,System.String,System.String)">
            <summary>
            overloaded version without ASelectedOperations
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.SubmitChanges(Ict.Common.Data.TTypedDataTable,Ict.Common.DB.TDBTransaction,Ict.Common.Verification.TVerificationResultCollection@,System.String)">
            <summary>
            overloaded version without sequence
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataAccess.SubmitChanges(Ict.Common.Data.TTypedDataTable,Ict.Common.DB.TDBTransaction,Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations,Ict.Common.Verification.TVerificationResultCollection@,System.String)">
            <summary>
            overloaded version without sequence, but with ASelectedOperations
            </summary>
        </member>
        <member name="P:Ict.Common.Data.TTypedDataAccess.RowCount">
            <summary>
            how many rows are in the current query or have been processed
            this is used for the Progress bar, to watch the current status
            </summary>
        </member>
        <member name="T:Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations">
            <summary>
            enumeration of operations that can be selected for SubmitChanges
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations.eUpdate">
            update records
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations.eDelete">
            delete records
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations.eInsert">
            add new records
        </member>
        <member name="F:Ict.Common.Data.TTypedDataAccess.eSubmitChangesOperations.eAll">
            execute all operations, no matter if it is update, delete, insert
        </member>
        <member name="T:Ict.Common.Data.TypedDataSet">
            <summary>
            This is the base class for the typed datasets.
            It deals with some strange behaviour when Mono and MS.net have to talk to each other.
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TypedDataSet.RemoveConstraintsFromSchema(System.String)">
            <summary>
            removes the constraints from the schema; needed for Mono and .Net cooperation
            </summary>
            <param name="strSchema">the schema to be modified</param>
            <returns></returns>
        </member>
        <member name="T:Ict.Common.Data.TTypedConstraint">
            <summary>
            this defines a constraint, foreign key
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedConstraint.FName">
            <summary>
            name of the constraint
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedConstraint.FTable1">
            <summary>
            first table involved, the one having the foreign key
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedConstraint.FTable2">
            <summary>
            the other table involved, it is refered to by the first table
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedConstraint.FKey1">
            <summary>
            the foreign key in the first table
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedConstraint.FKey2">
            <summary>
            usually the primary key or another unique key of the second table
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedConstraint.#ctor(System.String,System.String,System.String[],System.String,System.String[])">
             <summary>
             Create a typed constraint, that is reusable, and helps when deleting tables.
             Key2 points to table1 with Key1; e.g. key2 is the foreign key, key1 is a primary key
             the constraint is added to table2
             This follows the parameter order of System.Data.ConstraintCollection.Add( name, primaryKeyColumn, foreignKeyColumn)
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedConstraint.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="T:Ict.Common.Data.TTypedRelation">
            <summary>
            this class is derived from TTypedConstraint and has additional settings
            whether this relation is enabled or not
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedRelation.FCreateConstraints">
            <summary>
            do we want constraints to be created for this relation
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedRelation.FEnabled">
            <summary>
            is this relation enabled
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedRelation.#ctor(System.String,System.String,System.String[],System.String,System.String[],System.Boolean)">
             <summary>
             Create a typed relation, that is reusable, and helps when deleting tables.
             Table1/Key1 is the parent, Table2/Key2 is the child in the relationship
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="T:Ict.Common.Data.TTypedDataSet">
            <summary>
            our own Typed Dataset base class
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataSet.FConstraints">
            <summary>
            constraints in this dataset
            </summary>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataSet.FRelations">
            <summary>
            relations in this dataset
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.InitTables">
            <summary>
            for initialising the tables
            implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.InitTables(System.Data.DataSet)">
            <summary>
            for initialising the tables, of a specific dataset
            implemented by generated code
            </summary>
            <param name="ds">the dataset</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.InitConstraints">
            <summary>
            for initialising the constraints
            implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.InitVars">
            <summary>
            for initialising the columns
            implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.#ctor(System.String)">
            <summary>
            constructor with dataset name
            </summary>
            <param name="ADatasetName">name for the new typed dataset</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.MyOwnGetSerializationData(System.String,System.String)">
            <summary>
            there are sometimes problems between Mono and .Net, and this is the work around
            </summary>
            <param name="strSchema">the schema</param>
            <param name="diffGram">the data</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            constructor for serialization
            </summary>
            <param name="info">required for serialization</param>
            <param name="context">required for serialization</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.Clone">
             <summary>
             also copy the constraints and relations arrays
            
             </summary>
             <returns>cloned Dataset</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.InitClass">
            <summary>
            Initialise the class, calling abstract routines in the right order
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.MapTables">
            <summary>
            make sure that the typed variables are all referencing to the dataset
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.Merge(System.Data.DataTable)">
            <summary>
            overload that makes sure that the typed tables are mapped again
            </summary>
            <param name="ATable"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.Merge(System.Data.DataSet)">
            <summary>
            overload that makes sure that the typed tables are mapped again
            </summary>
            <param name="ADataSet"></param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.GetDataColumnArrayFromString(System.Data.DataTable,System.String[])">
             <summary>
             This returns an array of DataColumns, based on a Array of strings of column names of a given table
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableConstraint(Ict.Common.Data.TTypedConstraint)">
             <summary>
             enable a specific constraint
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableConstraints">
             <summary>
             Will add the constraints to the tables.
             The constraints should have been before added to FConstraints.
             Constraints will only be added if they don't exist already
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.DisableConstraints">
            <summary>
            disable all the constraints
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableConstraint(System.String)">
             <summary>
             Enable a specific constraint
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.DisableConstraint(System.String)">
             <summary>
             Disable a specific constraint
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.DisableRelationConstraints">
             <summary>
             Disable all constraints created because of a relation
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableRelation(Ict.Common.Data.TTypedRelation)">
             <summary>
             enable a specific relation
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableRelations">
             <summary>
             Will add the relations to the tables.
             The relations should have been before added to FRelations.
             Relations will only be added if they don't exist already
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.EnableRelation(System.String)">
             <summary>
             Enable a specific relation
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.DisableRelation(System.String)">
             <summary>
             Disable a specific relation
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.GetChangesTyped(System.Boolean)">
            <summary>
            returns a dataset with only necessary data
            depending on the parameter removeEmptyTables, the empty tables are not returned
            all rows that are not changed are not returned
            </summary>
            <returns>a new dataset with only modified data
            </returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.RemoveTable(System.String)">
            <summary>
            Remove a table fromt the dataset, and all constraints and references refering to it
            </summary>
            <param name="ATableName">table to remove</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.RemoveTables(System.Collections.Specialized.StringCollection)">
            <summary>
            remove a list of tables from the dataset (StringCollection)
            </summary>
            <param name="ATableNames">names of tables to be removed</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.RemoveTables(System.String[])">
            <summary>
            remove a list of tables from the dataset (array of string)
            </summary>
            <param name="ATableNames">names of tables to be removed</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.RemoveEmptyTables">
            <summary>
            remove all tables from the dataset that are empty
            </summary>
        </member>
        <member name="T:Ict.Common.Data.TTypedDataSet.TOtherDataSet">
            <summary>
            helper class to be able to use the standard serialization constructor
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataSet.TOtherDataSet.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            serialization constructor
            </summary>
            <param name="info">required for serialization</param>
            <param name="context">required for serialization</param>
        </member>
        <member name="T:Ict.Common.Data.TTypedDataTable">
            <summary>
            This is the base class for the typed datatables.
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="name">name of table</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.#ctor(System.Data.DataTable)">
            <summary>
            on purpose, this constructor does not call InitClass or InitVars;
            used for serialization
            </summary>
            <param name="tab">table for copying the table name</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.#ctor">
            <summary>
            default constructor
            not needed, but for clarity
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            serialization constructor
            </summary>
            <param name="info">required for serialization</param>
            <param name="context">required for serialization</param>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.InitClass">
            <summary>
            abstract method to be implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.InitVars">
            <summary>
            abstract method to be implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.CreateOdbcParameter(System.Int32)">
            <summary>
            abstract method to be implemented by generated code
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetChanges">
            <summary>
            make sure that we use GetChangesType instead of GetChanges
            </summary>
            <returns>throws an exception</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetChangesTypedInternal">
            <summary>
            our own version of GetChanges
            </summary>
            <returns>returns a typed table with the changes</returns>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.RemoveColumnsNotInTableTemplate(System.Data.DataTable)">
            <summary>
            remove columns that are not needed
            </summary>
            <param name="ATableTemplate">this table only contains the columns that should be kept</param>
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TableInfo">
            <summary>
            stores information about typed tables
            </summary>
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetTableNameSQL(System.Int16)">
            the table name as it is in the SQL database
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetTableName(System.Int16)">
            the table name in CamelCase
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetTableByName(System.String)">
            the table name in CamelCase
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetColumnNameSQL(System.Int16,System.Int16)">
            the column name as it is in the SQL database
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetLabel(System.Int16,System.Int16)">
            returns the translated label for the column
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetLength(System.Int16,System.Int16)">
            get the maximum length for the field
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetLength(System.String,System.String)">
            get the maximum length for the field
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetKeyColumnStringList(System.Int16,System.Int32[])">
            get the names of the columns that are part of the key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetPrimaryKeyColumnStringList(System.Int16)">
            get the names of the columns that are part of the primary key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetUniqueKeyColumnStringList(System.Int16)">
            get the names of the columns that are part of the unique key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetPrimaryKeyColumnOrdList(System.Int16)">
            get the order number of the columns that are part of the primary key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetUniqueKeyColumnOrdList(System.Int16)">
            get the order number of the columns that are part of a unique key
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetColumnStringList(System.Int16)">
            get the names of the columns in this table
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.GetColumn(System.Int16,System.String)">
            get the details of a column
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.CreateOdbcParameter(System.Int16,Ict.Common.TSearchCriteria)">
            create an odbc parameter for the given column
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.CreateOdbcParameter(System.Int16,System.Int32)">
            create an odbc parameter for the given column
        </member>
        <member name="P:Ict.Common.Data.TTypedDataTable.Count">
            <summary>
            the number of rows in the current table
            </summary>
        </member>
        <member name="T:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo">
            will be filled by generated code
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.orderNumber">
            identification of the column, by order
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.name">
            nice name of column (CamelCase)
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.dbname">
            name of the column as it is in the SQL database
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.label">
            Label (with translation if it is used on a generated screen on the client side)
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.odbctype">
            odbc type of the column
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.length">
            if this type has a length, here it is
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.bNotNull">
            can the column never be NULL
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.TTypedColumnInfo.#ctor(System.Int16,System.String,System.String,System.String,System.Data.Odbc.OdbcType,System.Int32,System.Boolean)">
            constructor
        </member>
        <member name="T:Ict.Common.Data.TTypedDataTable.TTypedTableInfo">
            will be filled by generated code
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.id">
            identification of the table, by order
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.name">
            nice name of table (CamelCase)
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.dbname">
            name of the table as it is in the SQL database
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.PrimaryKeyColumns">
            the order number of the columns that are part of the primary key
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.UniqueKeyColumns">
            the order number of the columns that are part of the unique key
        </member>
        <member name="F:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.columns">
            the columns of this table
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.#ctor(System.Int16,System.String,System.String,Ict.Common.Data.TTypedDataTable.TTypedColumnInfo[],System.Int32[])">
            constructor
        </member>
        <member name="M:Ict.Common.Data.TTypedDataTable.TTypedTableInfo.#ctor(System.Int16,System.String,System.String,Ict.Common.Data.TTypedDataTable.TTypedColumnInfo[],System.Int32[],System.Int32[])">
            constructor
        </member>
        <member name="T:Ict.Common.Data.DataUtilities">
            <summary>
            Contains Utility functions for ADO.NET Data operations.
            </summary>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.RemoveColumnsNotInTableTemplate(System.Data.DataTable,System.Data.DataTable)">
            <summary>
            Remove the columns from the table that are not part of the template table
            </summary>
            <param name="ATable">table to be modified</param>
            <param name="ATableTemplate">template with requested columns</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.DestinationSaveItemArray(System.Data.DataRow,System.Data.DataRow)">
            <summary>
            get an array of the values ordered by the columns in the destination table
            </summary>
            <param name="ADestinationRow">defines the desired order</param>
            <param name="ACopyRow">the values to be ordered</param>
            <returns>an array of ordered values</returns>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.ChangeDataTableToTypedDataTable(System.Data.DataTable@,System.Type,System.String)">
            <summary>
            convert a normal datatable to a typed datatable
            using reflection
            </summary>
            <param name="ADataTable">the table to be converted</param>
            <param name="ATypedDataTableType">the type of the typed datatable</param>
            <param name="ATableName">the name for the table</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CalculateHashAndSize(System.Data.DataTable,System.String@,System.Int32@)">
            <summary>
            calculate a hash for a table and the size of the table
            </summary>
            <param name="AHashDT">the table to be analysed</param>
            <param name="AHash">returns the hash value of the table</param>
            <param name="ASize">returns the size of the table</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CalculateHashAndSize(System.Data.DataView,System.String@,System.Int32@)">
            <summary>
            calculate a hash for a table and the size of the dataview
            </summary>
            <param name="AHashDV">the dataview to be analysed</param>
            <param name="AHash">returns the hash value of the table</param>
            <param name="ASize">returns the size of the table</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.HaveDataRowsIdenticalValues(System.Data.DataRow,System.Data.DataRow)">
            <summary>
            compare the values of two rows
            </summary>
            <param name="ADataRow1">first row</param>
            <param name="ADataRow2">second row</param>
            <returns>true if identical values</returns>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CopyModificationIDsOver(System.Data.DataRow,System.Data.DataRow)">
            <summary>
            copy the modification ids from one datarow to another
            </summary>
            <param name="ADestinationDR">datarow to be modified</param>
            <param name="ACopyDR">original values</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CopyModificationIDsOver(System.Data.DataTable,System.Data.DataTable)">
            <summary>
            copy the modification ids from one datatable to another
            </summary>
            <param name="ADestinationDT">datatable to be modified</param>
            <param name="ACopyDT">original values</param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CopyAllColumnValues(System.Data.DataRow,System.Data.DataRow)">
            <summary>
            copy all values from one row to the other; must have the same columns
            </summary>
            <param name="ASourceRow"></param>
            <param name="ADestinationRow"></param>
        </member>
        <member name="M:Ict.Common.Data.DataUtilities.CopyTo(System.Data.DataTable,System.Data.DataTable)">
            delete the destination table, copy all rows from the source table;
            we assume both tables have the same columns, same type.
            this is needed for datasets, when the table is readonly and cannot be assigned directly
        </member>
    </members>
</doc>
