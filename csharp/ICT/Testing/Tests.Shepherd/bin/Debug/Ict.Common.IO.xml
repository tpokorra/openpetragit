<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ict.Common.IO</name>
    </assembly>
    <members>
        <member name="T:Ict.Common.IO.TCsv2Xml">
            provides methods for converting CSV file to and from XML;
            this helps with adding values, rearranging columns etc;
            expects a header line with column names
        </member>
        <member name="M:Ict.Common.IO.TCsv2Xml.GetAllAttributesAndNodes(System.Xml.XmlNode,System.Collections.Generic.List{System.String}@,System.Collections.Generic.List{System.Xml.XmlNode}@)">
            needed for writing CSV file header;
            also collects the node to avoid another recursion
        </member>
        <member name="M:Ict.Common.IO.TCsv2Xml.Xml2Csv(System.Xml.XmlDocument,System.String)">
            <summary>
            format the XML into CSV so that it can be opened as a spreadsheet;
            this only works for quite simple files;
            hierarchical structures are flattened (using childOf column)
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TCsv2Xml.ParseCSV2Xml(System.String)">
            <summary>
            convert a CSV file to an XmlDocument.
            the first line is expected to contain the column names/captions
            the separator is read from the header line, and the captions require # at the start of each caption
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TCsv2Xml.ParseCSV2Xml(System.String,System.String)">
            <summary>
            convert a CSV file to an XmlDocument.
            the first line is expected to contain the column names/captions
            </summary>
        </member>
        <member name="T:Ict.Common.IO.EncryptionRijndael">
            contains functions to deal with encryption and decryption;
            see also PetraTools/GenerateEncryptionKey, and Petra/Shared/RemotingSinks
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.ReadSecretKey(System.String)">
            <summary>
            the key is stored as a base64 string to make it easier to handle the key;
            this method returns the clear version of the key to be used with encrypt and decrypt functions
            </summary>
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.CreateSecretKey(System.String)">
            store a key into a text file
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.Encrypt(System.Byte[],System.String,System.String@,System.String@)">
            encrypt a string message using a secret key that is known to both sender and recipient only;
            need to give the initialization vector to the recipient as well;
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.Decrypt(System.Byte[],System.String,System.String)">
            <summary>
            decrypt an encrypted message, using the secret key and the initialization vector that was used to encrypt the message
            </summary>
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.Encrypt(System.Byte[],System.IO.Stream,System.Byte[]@)">
            <summary>
            Encrypt a stream, create an initialization vector, which is transmitted with the message
            </summary>
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.Decrypt(System.Byte[],System.IO.Stream,System.Byte[])">
            Decrypt a stream, using the initialization vector, which was transmitted with the message
        </member>
        <member name="M:Ict.Common.IO.EncryptionRijndael.GetEncryptionName">
            <summary>
            the name of the encryption algorithm
            </summary>
        </member>
        <member name="T:Ict.Common.IO.XlChartType">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DArea">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DAreaStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DAreaStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DBarClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DBarStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DBarStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DColumn">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DColumnClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DColumnStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DColumnStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DLine">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DPie">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xl3DPieExploded">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlArea">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlAreaStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlAreaStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBarClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBarOfPie">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBarStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBarStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBubble">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlBubble3DEffect">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlColumnClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlColumnStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlColumnStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneBarClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneBarStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneBarStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneCol">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneColClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneColStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCloneColStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderBarClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderBarStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderBarStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderCol">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderColClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderColStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlCylinderColStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlDoughnut">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlDoughnutExploded">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLine">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLineMarkers">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLineMarkersStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLineMarkersStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLineStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlLineStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPie">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPieExploded">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPieOfPie">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidBarClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidBarStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidBarStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidCol">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidColClustered">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidColStacked">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlPyramidColStacked100">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlRadar">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlRadarFilled">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlRadarMarkers">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlStockHLC">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlStockOHLC">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlStockVHLC">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlStockVOHLC">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlSurface">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlSurfaceTopView">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlSurfaceTopViewWireframe">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlSurfaceWireframe">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlXYScatter">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlXYScatterLines">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlXYScatterLinesNoMarkers">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlXYScatterSmooth">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartType.xlXYScatterSmoothNoMarkers">
            <summary>todoComment</summary>
        </member>
        <member name="T:Ict.Common.IO.XlChartLocation">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartLocation.xlLocationAsNewSheet">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartLocation.xlLocationAsObject">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlChartLocation.xlLocationAutomatic">
            <summary>todoComment</summary>
        </member>
        <member name="T:Ict.Common.IO.XlDataLabelsType">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowNone">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowValue">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowPercent">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowLabel">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowLabelAndPercent">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.XlDataLabelsType.xlDataLabelsShowBubbleSizes">
            <summary>todoComment</summary>
        </member>
        <member name="T:Ict.Common.IO.TExcel">
            <summary>
            This contains some functions to write into Excel via remote calls
            constants from http:www.p6c.com/CommonTypelibs/O2000_EXCEL9.CSV
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TExcel.#ctor">
            <summary>
            Instantiate Microsoft Excel
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.NewSheet(System.String)">
            <summary>
            todoComment
            </summary>
            <param name="sheetName"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.GetRange(System.Int32,System.Int32)">
            <summary>
            Get a range object that contains cell (column, row).
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.GetRange(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            todoComment
            </summary>
            <param name="column"></param>
            <param name="row"></param>
            <param name="col2"></param>
            <param name="row2"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.SetValue(System.Object,System.Object)">
            <summary>
            Write value in cell.
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.SetFormula(System.Object,System.String)">
            <summary>
            Write formula in cell.
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.AddChart(System.String,System.String,System.Object,Ict.Common.IO.XlChartType,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            add a chart with dimensions and referencing range
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TExcel.AddChart(System.String,System.String,System.Object,Ict.Common.IO.XlChartType,System.Boolean,System.Boolean)">
            <summary>
            overload
            </summary>
            <param name="chartSheetName"></param>
            <param name="title"></param>
            <param name="valueRange"></param>
            <param name="typeOfChart"></param>
            <param name="withCategoryName"></param>
            <param name="withValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TExcel.AddChart(System.String,System.String,System.Object,Ict.Common.IO.XlChartType,System.Boolean)">
            <summary>
            overload
            </summary>
            <param name="chartSheetName"></param>
            <param name="title"></param>
            <param name="valueRange"></param>
            <param name="typeOfChart"></param>
            <param name="withCategoryName"></param>
        </member>
        <member name="M:Ict.Common.IO.TExcel.AddChart(System.String,System.String,System.Object,Ict.Common.IO.XlChartType)">
            <summary>
            overload
            </summary>
            <param name="chartSheetName"></param>
            <param name="title"></param>
            <param name="valueRange"></param>
            <param name="typeOfChart"></param>
        </member>
        <member name="M:Ict.Common.IO.TExcel.Show">
            <summary>
            overload
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TExcel.GiveUserControl">
            <summary>
            leave Excel to the user, disconnect this program of it
            </summary>
            <returns>void</returns>
        </member>
        <member name="T:Ict.Common.IO.TFileHelper">
            <summary>
            Helps in handling with certain aspects of files and compression.
            </summary>
        </member>
        <member name="T:Ict.Common.IO.TFileHelper.Streams">
            <summary>
            Helps in handling Streams and files.
            </summary>
        </member>
        <member name="T:Ict.Common.IO.TFileHelper.Streams.Compression">
            <summary>
            Helps in handling Zip-compression of Streams and files.
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TFileHelper.Streams.Compression.InflateFileIntoMemoryStream(System.String)">
            <summary>
            Loads a file, Zip-compresses it in memory and returns it as a MemoryStream.
            </summary>
            <param name="AFilePath">Filename (including Path) to read from.</param>
            <returns>A MemoryStream with the Zip-compressed contents of the file specified in <paramref name="AFilePath" />.</returns>
        </member>
        <member name="M:Ict.Common.IO.TFileHelper.Streams.Compression.InflateFilesIntoMemoryStream(System.String[])">
            <summary>
            Loads a any number of files, Zip-compresses them in memory into one Zip archive and returns it as a MemoryStream.
            </summary>
            <param name="AFilePaths">Array of Filenames (including Paths) to read from.</param>
            <returns>A MemoryStream with the Zip-compressed contents of all the files specified in <paramref name="AFilePaths" />.</returns>
        </member>
        <member name="M:Ict.Common.IO.TFileHelper.Streams.Compression.DeflateFilesFromStream(System.IO.Stream)">
            <summary>
            Uncompress a Zip-compressed Stream into a MemoryStream.
            </summary>
            <param name="AZippedStream">Stream containing files that are Zip-compressed.</param>
            <returns>A MemoryStream with the uncompressed contents of the Stream specified in <paramref name="AZippedStream" />.</returns>
        </member>
        <member name="T:Ict.Common.IO.TFileHelper.Streams.FileHandling">
            <summary>
            Helps in handling MemoryStreams and files.
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TFileHelper.Streams.FileHandling.LoadFileIntoStream(System.String)">
            <summary>
            Loads a file into a MemoryStream object.
            </summary>
            <param name="AFilePath">Filename (including Path) to read from.</param>
            <returns>A MemoryStream with the contents of the File specified in <paramref name="AFilePath" />.</returns>
        </member>
        <member name="M:Ict.Common.IO.TFileHelper.Streams.FileHandling.SaveStreamToFile(System.IO.Stream,System.String)">
            <summary>
            Saves a Stream into a file.
            </summary>
            <param name="AStream">The Stream whose contens should be saved to the file.</param>
            <param name="AFilePath">Filename (including Path) to write to.</param>
            <returns>void</returns>
        </member>
        <member name="T:Ict.Common.IO.TImportExportDialogs">
             <summary>
             support data liberation;
             see also http://sourceforge.net/apps/mediawiki/openpetraorg/index.php?title=Data_liberation
            
             </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportDialogs.ExportWithDialog(System.Xml.XmlDocument,System.String)">
            <summary>
            export data to a range of different file formats;
            ask the user for filename and file format
            </summary>
            <param name="doc"></param>
            <param name="ADialogTitle"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportDialogs.ExportWithDialogYMLGz(System.String,System.String)">
            <summary>
            export zipped yml string to file.
            ask the user for filename
            </summary>
            <param name="AZippedYML"></param>
            <param name="ADialogTitle"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportDialogs.ImportWithDialogYMLGz(System.String)">
            <summary>
            import a zipped yml file.
            if the file is a plain yml file, the content will be zipped.
            shows a dialog to the user to select the file to import
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportDialogs.ImportWithDialog(System.String)">
            <summary>
            convert from all sorts of formats into xml document;
            shows a dialog to the user to select the file to import
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportDialogs.ImportWithDialog(System.String,System.String@)">
            <summary>
            convert from all sorts of formats into xml document;
            shows a dialog to the user to select the file to import
            </summary>
            <returns></returns>
        </member>
        <member name="T:Ict.Common.IO.TImportExportTextFile">
            <summary>
            write and read a text file in a format that Petra 2.x uses
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TImportExportTextFile.FTextToWrite">
            <summary>
            this contains the context of the text file, all Write functions write into this string,
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TImportExportTextFile.FStartOfLine">
            <summary>
            useful when deciding if SPACE needs to be written or not (at beginning of line)
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TImportExportTextFile.FLinesToParse">
            <summary>
            this contains the context of the text file, when it is being read
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.StartWriting">
            <summary>
            initialise the stringbuilder for writing a new file
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.FinishWriting">
            <summary>
            returns the string that has been assembled during all the previous write function calls
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.InitReading(System.String[])">
            <summary>
            pass the lines that should be parsed
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.EndOfFile">
            <summary>
            is there more data to read?
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadNextStringItem">
            <summary>
            all items in the text file are either separated by newline or by SPACE
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.CheckForKeyword(System.String)">
            <summary>
            this will check if the next item is the quoted keyword.
            if this is true, the parser will proceed to next item
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.WriteLine">
            <summary>
            insert a new line
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.String)">
            <summary>
            insert a string. will use quotes
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadString">
            <summary>
            read a string. strip off the quotes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.WriteMultiLine(System.String)">
            <summary>
            insert a text which can contain several lines, and some characters will be escaped automatically
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadMultiLine">
            <summary>
            read a text which can contain several lines, restore all escaped characters
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.Boolean)">
            <summary>
            write a boolean value
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadBoolean">
            <summary>
            read a boolean value
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.Int64)">
            <summary>
             write an Int64 value
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadInt64">
            <summary>
            read an Int64 value
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.Int32)">
            <summary>
            write an Int32 value
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadInt32">
            <summary>
            read an Int32 value
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.Decimal)">
            <summary>
            write a decimal value
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadDecimal">
            <summary>
            read a Decimal value
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.Nullable{System.DateTime})">
            <summary>
            write a date. if null, write questionmark
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadNullableDate">
            <summary>
            read a DateTime value that can be null
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.Write(System.DateTime)">
            <summary>
            write a date
            </summary>
            <param name="AValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TImportExportTextFile.ReadDate">
            <summary>
            read a DateTime value
            </summary>
        </member>
        <member name="T:Ict.Common.IO.PackTools">
             <summary>
             Some helpful wrapper functions for packing and unpacking files and directories.
            
             It is mainly used by the patch program.
             For some special cases it makes use of an external application, 7zip. This needs to be on the PATH environment variable.
             Based on the SharpZipLib library
             </summary>
        </member>
        <member name="M:Ict.Common.IO.PackTools.Unzip(System.String,System.String)">
            <summary>
            overloaded
            </summary>
            <param name="ATargetDirectory"></param>
            <param name="AZipFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.Unzip(System.String,System.String,System.Collections.ArrayList,System.Boolean)">
            <summary>
            todoComment
            </summary>
            <param name="ATargetDirectory"></param>
            <param name="AZipFileName"></param>
            <param name="AFilesToUnzip">if nil, unzip all; otherwise only the specified files (specified by internal path and filename) are unzipped</param>
            <param name="ADisregardPaths">store the extracted files in the current directory, despite the directory structure in the zip file</param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ZipDirectory(System.String,System.String,System.Collections.Specialized.StringCollection)">
            <summary>
            create a zip file from a directory
            </summary>
            <param name="ADirectory"></param>
            <param name="AZipFileName"></param>
            <param name="AExcludeDirectories"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ZipDirectory(System.String,System.String)">
            <summary>
            overload
            </summary>
            <param name="ADirectory"></param>
            <param name="AZipFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ZipDirectory(System.String)">
            <summary>
            overload
            </summary>
            <param name="ADirectory"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ZipString(System.String)">
            zip a utf8 string using gzip into a base64 encoded string
        </member>
        <member name="M:Ict.Common.IO.PackTools.UnzipString(System.String)">
            unzip a base64 encoded string and return the original utf8 string using gzip
        </member>
        <member name="M:Ict.Common.IO.PackTools.ExtractTarGz(System.String,System.String)">
            <summary>
            extract a tar gz file
            </summary>
            <param name="ATmpDirectory"></param>
            <param name="AFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ExtractTar(System.String,System.String)">
            <summary>
            extract a tar file
            </summary>
            <param name="ATmpDirectory"></param>
            <param name="AFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.Extract7Zip(System.String,System.String)">
            <summary>
            extract a 7zip file, using external 7z installation
            </summary>
            <param name="ATmpDirectory"></param>
            <param name="ASrcFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.PackTar(System.String,System.String)">
            <summary>
            create a tar file
            </summary>
            <param name="ADirectory"></param>
            <param name="ATarFileName"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.PackTar(System.String)">
            <summary>
            overload
            </summary>
            <param name="ADirectory"></param>
        </member>
        <member name="M:Ict.Common.IO.PackTools.ExtractSRPM(System.String,System.String)">
            <summary>
            unpack an SRPM file
            </summary>
            <param name="ATmpDirectory"></param>
            <param name="AFileName"></param>
        </member>
        <member name="T:Ict.Common.IO.TFileVersionInfo">
            <summary>
            our own type for version information for a file
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TFileVersionInfo.FileMajorPart">
            <summary>MajorPart.MinorPart.BuildPart-PrivatePart</summary>
        </member>
        <member name="F:Ict.Common.IO.TFileVersionInfo.FileMinorPart">
            <summary>MajorPart.MinorPart.BuildPart-PrivatePart</summary>
        </member>
        <member name="F:Ict.Common.IO.TFileVersionInfo.FileBuildPart">
            <summary>MajorPart.MinorPart.BuildPart-PrivatePart</summary>
        </member>
        <member name="F:Ict.Common.IO.TFileVersionInfo.FilePrivatePart">
            <summary>MajorPart.MinorPart.BuildPart-PrivatePart</summary>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="ARPMStyleVersion">2.2.35: major.minor.buildprivate</param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.#ctor(System.Diagnostics.FileVersionInfo)">
            <summary>
            constructor
            </summary>
            <param name="AInfo"></param>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.#ctor(System.Version)">
            <summary>
            constructor
            </summary>
            <param name="AVersion"></param>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.#ctor(Ict.Common.IO.TFileVersionInfo)">
            <summary>
            copy constructor
            </summary>
            <param name="AInfo"></param>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.Compare(Ict.Common.IO.TFileVersionInfo)">
            <summary>
            compare two file versions
            </summary>
            <returns>-1 if this &lt; ACmp, 1 if this &gt; ACmp, and 0 if equals</returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.ToString">
            <summary>
            print file version to string
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.ToStringDotsHyphen">
            <summary>
            print file version to string, with hyphen as last separator
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.GetVersionsFromDiffZipName(System.String)">
            <summary>
            returns the version numbers of the patch;
            e.g. Patch-win_2.2.35_2.2.43.zip should return 2.2.35 and 2.2.43
            </summary>
            <param name="APatchZipFile"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.GetLatestPatchVersionFromDiffZipName(System.String)">
            <summary>
            what is the latest patch; look at the name of the diff file
            </summary>
            <param name="APatchZipFile"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.GetStartVersionFromDiffZipName(System.String)">
            <summary>
            what is the start version; look at the name of the diff file
            </summary>
            <param name="APatchZipFile"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.PatchApplies(System.String)">
            <summary>
            would this patch file apply to the current installed version
            </summary>
            <param name="APatchZipFile"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TFileVersionInfo.PatchApplies(System.String,Ict.Common.IO.TFileVersionInfo)">
            <summary>
            would this patch file apply to the current installed version
            </summary>
            <param name="APatchZipFile"></param>
            <param name="AMaxVersion">maximum version to upgrade to, usually this is the version of the exe files</param>
            <returns></returns>
        </member>
        <member name="T:Ict.Common.IO.TPatchFileInfo">
            <summary>
            info about a patch file
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.NewFileDateTime">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.OldMd5sum">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.NewMd5sum">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.StoredVersion">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.FormatVersion">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.newsize">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.bzctrllen">
            <summary>todoComment</summary>
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchFileInfo.bzdatalen">
            <summary>todoComment</summary>
        </member>
        <member name="T:Ict.Common.IO.TPatchTools">
             <summary>
             This class provides functions for easy
             generation and application of binary patches to program files.
            
             It is based on the program bsdiff from Colin Percival.
             Find the original source and license here:
             http://www.daemonology.net/bsdiff/
            
             The modified format (based on BSDIFF40) is:
               0 8 "ICTDIFF1"
               8 8 X
               16  8 Y
               24  8 sizeof(newfile)
               32 8 Date and Time of the new file (Ticks, Int64)
               40 32 Md5sum of old file
               72 32 Md5sum of new file
               104 8 FileVersion of the old dll
               112  X bzip2(control block)
               112+X  Y bzip2(diff block)
               112+X+Y  ??? bzip2(extra block)
               112  X bzip2(control block)
               112+X  Y bzip2(diff block)
               112+X+Y  ??? bzip2(extra block)
            
             with control block a set of triples (x,y,z) meaning "add x bytes
             from oldfile to x bytes from the diff block; copy y bytes from the
             extra block; seek forwards in oldfile by z bytes".
            
             This implementation does only support BSDIFF40, version 2
             </summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.BZ_COMPRESSION_LEVEL">
            <summary>maximum is 9, quite slow, and memory consuming</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.HEADER_SIZE">
            <summary>our own user defined header for patch files</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FORMAT_DESCR">
            <summary>identify our patch version</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FListOfNewPatches">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FInstallPath">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FVersionPostFix">
            <summary>eg. bin30 has postfix 30</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FBinPath">
            <summary>
            calculated from FInstallPath and FVersionPostFix
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FTmpPath">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FDatPath">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FPatchesPath">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FRemotePatchesPath">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FCurrentlyInstalledVersion">
            <summary>todoComment</summary>
        </member>
        <member name="F:Ict.Common.IO.TPatchTools.FLatestAvailablePatch">
            <summary>todoComment</summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.offtout(System.Int64,System.Byte[]@)">
            <summary>
            required for creating the binary diff
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.offtin(System.Byte[],System.Int32)">
            <summary>
            required for applying a binary patch
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.loopread(ICSharpCode.SharpZipLib.BZip2.BZip2InputStream@,System.Byte[]@,System.Int32,System.Int32)">
            <summary>
            required for applying a binary patch
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.bz2read(ICSharpCode.SharpZipLib.BZip2.BZip2InputStream@,System.Int32,System.String)">
            <summary>
            required for applying a binary patch
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CreateDiff_External(System.String,System.String,System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            required for creating the binary diff
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CreateDiff(System.String,System.String,System.String)">
            <summary>
            Create a binary diff between AFileName1 and AFileName2, and store the differences in AFileNameDiff this version uses the C bsdiff program to generate the patch; much faster
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.ReadHeader(System.String,Ict.Common.IO.TPatchFileInfo@)">
            <summary>
            called by ApplyPatch, can also be useful to analyse patch files
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.ApplyPatch(System.String,System.String,System.String)">
            <summary>
            Apply a patch to an existing file, and create a new file applies a single patch to one file; if the oldfile does not have the expected checksum:   if there is already a file with the additional extension .orig, then this is compared with
            the md5sum of the new file   also the old file is compared with the md5sum of the new file.   if the file is already there, it is copied to ANewFile generally: oldfile is not touched, and there is always a newfile created, either copied
            or patched. the orig file is left untouched
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.GetMd5Sum(System.String)">
            <summary>
            get the md5sum hash of a file
            </summary>
            <param name="ADLLName"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CheckMd5Sum(System.String,System.String)">
            <summary>
            check the hash sum of a file, and compare it to an expected value
            </summary>
            <param name="ADLLName"></param>
            <param name="AExpectedMd5Sum"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.IsSame(System.String,System.String)">
            <summary>
            compare the size and md5sum of files
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            constructor;
            to be used to actually install patches
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CheckForRecentPatch">
            <summary>
            check whether there is a patch available; if this is a remote version, try to download a patch from the server this will also get the version of the currently installed code, and the list of patches that can be installed, in local
            variables
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CheckForRecentPatch(System.Boolean,System.String@)">
            <summary>
            check whether there is a patch available; if this is a remote version, try to download a patch from the server this will also get the version of the currently installed code, and the list of patches that can be installed, in local
            variables
            </summary>
            <param name="AShowStatus">Set to true to show status messages as a MessageBox
            if there is a problem, or to false to have them returned in
            <paramref name="AStatusMessage" /></param>.
            <param name="AStatusMessage">A Status Message in case there is a problem AND
            <paramref name="AShowStatus" /> is false.</param>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CheckPatchesConsistent(System.Collections.SortedList)">
            <summary>
            see if any patches are missing; is there a direct line between FCurrentlyInstalledVersion and FLatestAvailablePatch?
            </summary>
            <returns>return a list of all patches that should be applied. empty list if there is a problem</returns>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.GetCurrentPatchVersion">
            <summary>
            the patch of the current installed application
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.GetLatestPatchVersion">
            <summary>
            the latest available patch version
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TPatchTools.CopyLatestPatchProgram(System.String)">
            <summary>
            this procedure makes sure that the latest version of the patch tool is being used;
            the latest available executable and required dlls are copied to the patch tmp directory
            </summary>
            <returns>void</returns>
        </member>
        <member name="T:Ict.Common.IO.TDlgSelectCSVSeparator">
            <summary>
            Description of SelectCSVSeparator.
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TDlgSelectCSVSeparator.#ctor(System.Boolean)">
            <summary>
            constructor
            TODO: also select date format?
            TODO: select if first row contains captions? or use a parameter to avoid or request captions?
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TDlgSelectCSVSeparator.components">
            <summary>
            Designer variable used to keep track of non-visual components.
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TDlgSelectCSVSeparator.Dispose(System.Boolean)">
            <summary>
            Disposes resources used by the form.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Ict.Common.IO.TDlgSelectCSVSeparator.InitializeComponent">
            <summary>
            This method is required for Windows Forms designer support.
            Do not change the method contents inside the source code editor. The Forms designer might
            not be able to load this method if it was changed manually.
            </summary>
        </member>
        <member name="P:Ict.Common.IO.TDlgSelectCSVSeparator.SelectedSeparator">
            <summary>
            read the separator that the user has selected
            </summary>
        </member>
        <member name="P:Ict.Common.IO.TDlgSelectCSVSeparator.DateFormat">
            <summary>
            read/set the date format that the user has selected
            </summary>
        </member>
        <member name="P:Ict.Common.IO.TDlgSelectCSVSeparator.NumberFormatIndex">
            <summary>
            read the number format that the user has selected
            </summary>
        </member>
        <member name="P:Ict.Common.IO.TDlgSelectCSVSeparator.CSVFileName">
            <summary>
            set the filename for CSV
            </summary>
        </member>
        <member name="T:Ict.Common.IO.TSmtpSender">
            <summary>
            this is a small wrapper around the .net SMTP Email services
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TSmtpSender.#ctor(System.String,System.Int32,System.Boolean,System.String,System.String,System.String)">
            <summary>
            setup the smtp client
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TSmtpSender.#ctor">
            <summary>
            setup the smtp client from the config file or command line parameters
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TSmtpSender.SendMessage(System.Net.Mail.MailMessage@)">
            <summary>
            Send an email message
            </summary>
            <param name="AEmail">on successful sending, the header is modified with the sent date</param>
            <returns>true if email was sent successfully</returns>
        </member>
        <member name="T:Ict.Common.IO.THTTPUtils">
            <summary>
            a few simple functions to access content from the web
            </summary>
        </member>
        <member name="M:Ict.Common.IO.THTTPUtils.ReadWebsite(System.String)">
            <summary>
            read from a website;
            used to check for available patches
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.THTTPUtils.ReadWebsite(System.String,System.Collections.Generic.SortedList{System.String,System.String})">
            <summary>
            overload: encode all the values for the parameters and retrieve the website
            </summary>
        </member>
        <member name="M:Ict.Common.IO.THTTPUtils.DownloadFile(System.String,System.String)">
            <summary>
            download a patch or other file from a website;
            used for patching the program
            </summary>
            <param name="url"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="T:Ict.Common.IO.ProcessFileType">
            <summary>
            delegate to apply an operation on the file
            </summary>
        </member>
        <member name="T:Ict.Common.IO.TTextFile">
            Some useful functions for dealing with text files;
            only used for PetraTools at the moment
        </member>
        <member name="M:Ict.Common.IO.TTextFile.RecurseFilesAndDirectories(System.String,System.String,Ict.Common.IO.ProcessFileType)">
            todo: exclude directory names, e.g. CSV, see PetraTools\ProgressConverter\AnalyseProgressFiles.cs
        </member>
        <member name="M:Ict.Common.IO.TTextFile.Dos2Unix(System.String)">
            remove carriage return
        </member>
        <member name="M:Ict.Common.IO.TTextFile.Unix2Dos(System.String)">
            add carriage return
        </member>
        <member name="M:Ict.Common.IO.TTextFile.SameContent(System.String,System.String)">
            <summary>
            check if the two text files have the same content
            </summary>
            <param name="filename1"></param>
            <param name="filename2"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TTextFile.ReplaceCopyRightYear(System.String)">
            <summary>
            make sure generated files are not rewritten if only the copyright has changed in the file header
            </summary>
            <param name="ALine"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TTextFile.SameContent(System.String,System.String,System.Boolean)">
            <summary>
            check if the two text files have the same content
            </summary>
            <param name="filename1"></param>
            <param name="filename2"></param>
            <param name="AIgnoreNewLine"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TTextFile.UpdateFile(System.String,System.Boolean)">
             <summary>
             this will compare the original file with the file that has the same name but an extension .new additionally at the end
             if the files have identical content, the new file is dropped
             otherwise the original file is backed up, and the new file is renamed to the original file name
            
             the intention is to generate code, but not to touch it for VCS if not necessary
             </summary>
             <param name="AOrigFilename">the original name of the file</param>
             <param name="AIgnoreNewLine">should ignore line break character differences</param>
             <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TTextFile.UpdateFile(System.String)">
             <summary>
             this will compare the original file with the file that has the same name but an extension .new additionally at the end
             if the files have identical content, the new file is dropped
             otherwise the original file is backed up, and the new file is renamed to the original file name
            
             the intention is to generate code, but not to touch it for VCS if not necessary.
            
             this overload will compare line endings as well.
             </summary>
             <param name="AOrigFilename"></param>
             <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TTextFile.GetFileEncoding(System.String)">
            StreamReader DetectEncodingFromByteOrderMarks does not work for ANSI?
            therefore we have to detect the encoding by comparing the first bytes of the file
        </member>
        <member name="T:Ict.Common.IO.TXMLElement">
             <summary>
             This class represents one single entity.
             It is normally used as a super class to a specific object type
            
             </summary>
        </member>
        <member name="F:Ict.Common.IO.TXMLElement.order">
             <summary>
             if the element is one of many in the group, here the order is saved
            
             </summary>
        </member>
        <member name="M:Ict.Common.IO.TXMLElement.#ctor(System.Int32)">
            <summary>
            initialises the element with the given order
            </summary>
            <param name="order">the index of the element in the group it belongs to
            </param>
            <returns>void</returns>
        </member>
        <member name="T:Ict.Common.IO.TXMLGroup">
             <summary>
             This class represents a group of entities.
            
             </summary>
        </member>
        <member name="F:Ict.Common.IO.TXMLGroup.List">
            <summary>
            list of the entities in this group
            </summary>
        </member>
        <member name="F:Ict.Common.IO.TXMLGroup.Id">
            <summary>
            identifier for the group
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroup.#ctor(System.Int32)">
            <summary>
            constructor
            </summary>
            <param name="id"></param>
        </member>
        <member name="T:Ict.Common.IO.TXMLParser">
             <summary>
             This class provides methods for parsing an XML document and assign the contents
             to a representation in memory.
            
             The TXMLParser class provides an easy approach to parse elements
             and groups of elements of an XML document.
             It provides functions for easily navigate through an XML document
             and to retrieve attributes etc.
             It makes use of the .Net XML parser library.
             </summary>
        </member>
        <member name="F:Ict.Common.IO.TXMLParser.myDoc">
            <summary>
            the XmlDocument that is currently parsed
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.#ctor(System.String,System.Boolean)">
            <summary>
            constructor
            </summary>
            <param name="filename"></param>
            <param name="withValidation"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.#ctor(System.String)">
            <summary>
            constructor; opens the file with validation
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.#ctor(System.Xml.XmlDocument)">
            <summary>
            can be used for document that is parsed from YML
            </summary>
            <param name="ADoc">the document that should be parsed</param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.#ctor(Ict.Common.IO.TXMLParser)">
            <summary>
            copy constructor
            </summary>
            <param name="AReuseParser"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.ValidationCallback(System.Object,System.Xml.Schema.ValidationEventArgs)">
            <summary>
            this method is called if validation fails
            </summary>
            <param name="sender">who is sending this</param>
            <param name="args">information about the validation error</param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetDocument">
             <summary>
             retrieves the document, in case the document should be parsed not by a derived class
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.XmlToString(System.Xml.XmlDocument)">
            <summary>
            print an xml document to string;
            this can be necessary for transmitting between server and client, since XmlDocument is not serializable
            </summary>
            <param name="ADoc"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.XmlToStringIndented(System.Xml.XmlDocument)">
            <summary>
            print an xml document to string with indentation
            </summary>
            <param name="ADoc"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.MoveElementNameToAttribute(System.Xml.XmlNode,System.Xml.XmlNode)">
            used by XmlToString
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.XmlToString(System.Xml.XmlDocument,System.Boolean)">
            <summary>
            this is necessary to be able to store XML files that can be parsed by DTD/Schema mechanisms;
            for YML, we have the name of an element not as an attribute, but the element name itself;
            this would never work for validating xml; therefore all Elements are called XmlElement, with attribute name
            </summary>
            <param name="ADoc"></param>
            <param name="AMoveElementNamesToAttribute"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.NextNotBlank(System.Xml.XmlNode)">
            <summary>
            test the given node, if it is a comment or is empty; if it is empty, try the next nodes.
            </summary>
            <param name="cur2">the current node</param>
            <returns>the current or the first next node with actual content
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetNextEntity(System.Xml.XmlNode)">
            <summary>
            get the next code that is a proper entity (i.e. no comment, not empty)
            </summary>
            <param name="cur">the current node</param>
            <returns>the next node with actual content
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetChild(System.Xml.XmlNode,System.String)">
            <summary>
            return the child with the given name, if it exists; otherwise return null
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.FindNodeRecursive(System.Xml.XmlNode,System.String)">
            <summary>
            find a node somewhere in the xml document by its name
            </summary>
            <param name="AParentNode"></param>
            <param name="ANodeNameToSearch"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.SetAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            add or set an attribute value
            </summary>
            <param name="cur"></param>
            <param name="AAttribName"></param>
            <param name="AAttribValue"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.RenameAttribute(System.Xml.XmlNode,System.String,System.String)">
            <summary>
            rename an existing attribute
            </summary>
            <param name="cur"></param>
            <param name="AAttribOldName"></param>
            <param name="AAttribNewName"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            retrieve the value of an attribute. Does prevent unnecessary exceptions, if the attribute is not existing
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <returns>the value of the attribute, or an empty string if it is not existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetAttributeRecursive(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            retrieve the value of an attribute. Does prevent unnecessary exceptions, if the attribute is not existing.
            check the parent nodes for the attribute, if the current node does not have that attribute
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <param name="AInheritAttributes">return all the values of the parent nodes as well</param>
            <returns>the value of the attribute, or the CSV list of attribute values of the parents and the node,
              or an empty string if the attribute is not existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.HasAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            retrieve whether the node has an attribute with the given name or not
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <returns>true if the attribute is existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetIntAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            retrieve the int value of an attribute. Does prevent unnecessary exceptions, if the attribute is not existing
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <returns>the value of the attribute, or -1 if it is not existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetBoolAttribute(System.Xml.XmlNode,System.String,System.Boolean)">
            <summary>
            retrieve the boolean value of an attribute. Understands all sorts of notation (yes|no, true|false, 0|1)
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <param name="defaultvalue">the default value if the attribute is not existing; optional: false</param>
            <returns>the value of the attribute, or the default value if it is not existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetBoolAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            overload for GetBoolAttribute, assuming default value is false
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <returns>the value of the attribute, or false if it is not existing
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.GetDecimalAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            retrieve the decimal value of an attribute. Does prevent unnecessary exceptions, if the attribute is not existing
            </summary>
            <param name="cur">the current node</param>
            <param name="attrib">the name of the attribute</param>
            <returns>the value of the attribute, or -1 if it is not existing
            </returns>
        </member>
        <member name="T:Ict.Common.IO.TXMLParser.MyUrlResolver">
            <summary>
            this fixes the problem that we have the filename of the DTD with a relative path name in the XML file
            this only works for situations with the dtd file in the same directory as the xml file
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.MyUrlResolver.#ctor(System.String)">
            <summary>
            pass the path of the xml file to build the proper path for the dtd file
            </summary>
            <param name="AXmlFilePath"></param>
        </member>
        <member name="M:Ict.Common.IO.TXMLParser.MyUrlResolver.GetEntity(System.Uri,System.String,System.Type)">
            <summary>
            overload this method to get the dtd from the same directory as the xml file
            </summary>
        </member>
        <member name="T:Ict.Common.IO.TXMLGroupParser">
            <summary>
            a parser for a group of entities
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.#ctor(System.String)">
            <summary>
            constructor; opens an xml document, with validation
            </summary>
            <param name="filename">name of the xml document</param>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.#ctor(System.String,System.Boolean)">
            <summary>
            constructor; opens an xml document
            </summary>
            <param name="filename">name of the xml document</param>
            <param name="withValidation">should the document be validated</param>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.ParseGroup(System.Xml.XmlNode,System.Int32@,System.String,System.Xml.XmlNode@)">
            <summary>
            This method needs to be implemented by a derived class,
            because it needs to know how to parse all the entities in the document.
            It is a template for reading a group of entities.
            </summary>
            <param name="cur2">The current node in the document that should be parsed</param>
            <param name="groupId">The id of the previous group object of this type</param>
            <param name="entity">The name of the elements that make up the group</param>
            <param name="newcur">After parsing, the then current node is returned in this parameter</param>
            <returns>The group of elements, or nil
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.Parse(System.Xml.XmlNode,System.Int32@,System.String)">
            <summary>
            This method needs to be implemented by a derived class,
            because it needs to know how to parse all the entities in the document.
            It is a template for reading one or more entities of the same type.
            </summary>
            <param name="cur">The current node</param>
            <param name="groupId">The id of the current group that the elements will belong to</param>
            <param name="entity">The name of the entity that should be read</param>
            <returns>the last of the read entities
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.Parse(System.String,System.Xml.XmlNode@,System.Int32@,System.String)">
            <summary>
            If the current node holds a entity of type groupentity,
            then the contained elements of type entity are parsed.
            </summary>
            <param name="groupentity">The name of the entity that holds the group of elements</param>
            <param name="cur">The current node</param>
            <param name="groupId">The current id for the group.
            This number will be increased and then used to create the new group.</param>
            <param name="entity">The name of the entitiy that represents the elements</param>
            <returns>The group of elements, or nil if node does not point to that group entity or the group entity is empty.
            </returns>
        </member>
        <member name="M:Ict.Common.IO.TXMLGroupParser.ParseGroup(System.Xml.XmlNode,System.Int32@,System.String)">
            <summary>
            a wrapper for the other parseGroup method,
            in case after the parsing the current node does not need to be known
            </summary>
            <param name="cur2">The current node in the document that should be parsed</param>
            <param name="groupId">The id of the previous group object of this type</param>
            <param name="entity">The name of the elements that make up the group</param>
            <returns>The group of elements, or nil
            </returns>
        </member>
        <member name="T:Ict.Common.IO.TYml2Xml">
             <summary>
             TYml2Xml is able to parse a YML file and store it in an XmlDocument
            
             Simple YAML to XML converter
             could have also used http://yaml-net-parser.sourceforge.net/default.html#intro
             But I prefer to write YAML files but to work with XML in the program.
             The yaml net parser would just be another interface to understand how to step through the document.
            
             See also the spec http://yaml.org/spec/1.2/
            
             We only support:
               indentation: http://yaml.org/spec/1.2/#id2577368
                    only use spaces, no tabs for indentation
                    Each node must be indented further than its parent node.
                    All sibling nodes must use the exact same indentation level.
            
                    comment lines start with #, can be indented
                    separators are comma and colon, lists are defined by curly and square brackets {} and []
                    values can be quoted to escape the colon or comma
            
                    name and colon (name:) is converted into an XML element as a parent for the following indented lines
                      indention only happens after node and colon without content
                    scalar: name and colon and a literal is converted into an attribute of the current XML element
                    sequence: [element1, element2, element3] are translated to &lt;element name=&quot;element1&quot;/&gt;&lt;element name=&quot;element2&quot;/&gt; below the parent node
                    mapping: name and value assignments {size=10, help=Test with spaces} are converted into attributes of the parent node
            
                    not supported:
                       node names cannot be quoted to escape colons
                       {params: size=10, help=Test with spaces}: leave out the params
                       [=name, =id, address] sorting columns are not identified this way
            
                    This class supports the loading of several derived files,
                    and overwriting the data of the base files;
                    todo: make a tag so that everything is pushed into base, before the last file is loaded
                          change the code: move only attributes into base tag
                                           add an attribute to elements that have been in base, base=&quot;yes&quot;
                                           this way the order of elements can be maintained easily,
                                           but it is still known which elements and attributes have been added since the tag
                          reactivate the check again, in ProcessXAML.cs: if (TXMLParser.GetAttribute(rootNode, &quot;ClassType&quot;) != &quot;abstract&quot;)
                    todo: save the last file after modification have been done to the xml structure (eg. loaded from csharp file)
             </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="AFilename"></param>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.#ctor(System.String[])">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetElementName(System.Xml.XmlNode)">
            <summary>
            return either the name from the attribute, or the element name
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.CheckName(System.String)">
            <summary>
            check if the name can be used as an element name for XML
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.Xml2YmlGz(System.Xml.XmlDocument)">
            <summary>
            format the XML into zipped YML and return as Base64 string
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.Xml2Yml(System.Xml.XmlDocument,System.String)">
            <summary>
            format the XML into YML to increase readability and save to file
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ReadHeader(System.String,System.String@)">
            <summary>
            This method can be used to check if this is the correct file type,
            and also find out the baseyaml or baseclass
            </summary>
            <returns>false if the yaml file cannot be read or interpreted</returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ThrowException(System.String,System.Int32)">
            throw an exception and tell the current position while reading the yaml file
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetAbsoluteIndentation(System.Int32)">
            returns -1 for comments or invalid line numbers,
            otherwise the number of spaces
            throws exception if there is a tab in the indentation
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetAbsoluteIndentationNext(System.Int32)">
            @returns the absolute indentation of the next valid line (skipping comments)
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetIndentationNext(System.Int32)">
            @returns +1 if next line is more indented than the current line (skipping comments),
            -1 if next line is less indented, or current line is last line
            0 if current line has same identation than the next line
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetNextLine">
            <summary>
            does not return comment lines
            </summary>
            <returns>null if no line available</returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.SplitNodeStatic(System.String,System.String@,System.String@)">
            <summary>
            same as SplitNode, but without an Exception, because that requires attributes from the class
            </summary>
            <param name="line"></param>
            <param name="nodeName"></param>
            <param name="nodeContent"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ReferenceNodes(System.Xml.XmlDocument)">
            fill sorted list which contains a reference to each node by name
        </member>
        <member name="F:Ict.Common.IO.TYml2Xml.XMLELEMENT">
            the name used for elements in generated xml code
        </member>
        <member name="F:Ict.Common.IO.TYml2Xml.ROOTNODEINTERNAL">
            the name used for root node in generated xml code
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.CreateXmlDocument">
            create an empty xml document, which will be filled with the data from the yaml file
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ParseYML2XML">
            <summary>
            loads an yml document into one xml document
            </summary>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ParseYML2XML(System.Xml.XmlDocument,System.Int32)">
            <summary>
            merges several yml documents into one xml document, and maintains their inheritance hierarchy
            for nodes that have the same name
            </summary>
            <param name="AMergeDoc"></param>
            <param name="ADepth"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetChildren(System.Xml.XmlNode,System.Boolean)">
            <summary>
            get all children nodes of a given node;
            depending on parameter, include the inherited nodes or not
            the nodes will be sorted by the order flag (AlwaysFirst, AlwaysLast)
            </summary>
            <param name="node"></param>
            <param name="AConsiderBase">include the inherited nodes</param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.Parent(System.Xml.XmlNode)">
            get the parent node
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.SetAttribute(System.Xml.XmlNode,System.String,System.String)">
            SetAttribute will never consider the base and the xml hierarchy; use Tag to move things to base
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.ClearAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            remove attribute
            </summary>
            <param name="xmlNode"></param>
            <param name="name"></param>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.HasAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            check for the attribute; if the current node does not have it, check the base node
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetAttribute(System.Xml.XmlNode,System.String)">
            <summary>
            get the attribute; if the current node does not have it, check the base node
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetAttributeRecursive(System.Xml.XmlNode,System.String)">
            <summary>
            if the current node does not have the attribute, try the parent nodes
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.HasAttributeRecursive(System.Xml.XmlNode,System.String)">
            <summary>
            if the current node does not have the attribute, try the parent nodes
            </summary>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetAttributes(System.Xml.XmlNode)">
            <summary>
            get all attributes, even from base node
            </summary>
            <param name="xmlNode"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetChild(System.Xml.XmlNode,System.String)">
            <summary>
            get the child node with the given name;
            considers base nodes as well
            </summary>
            <param name="node"></param>
            <param name="childName"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetElements(System.Xml.XmlNode,System.String)">
            <summary>
            overload for GetElements, with the main node and the name of the child node that has the elements
            </summary>
            <param name="node"></param>
            <param name="childName"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetElements(System.Xml.XmlNode)">
            convert elements of a sequence into a string collection
            checks for duplicates, and removes names with a tilde character ~ in front
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.LoadChild(System.Xml.XmlNode,System.String,System.Int32)">
            TYml2Xml.LoadChild will either
            reuse an element, move an existing leaf from base to the main node, or create a new element
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.GetBaseNode(System.Xml.XmlNode)">
            check if parent already has a base element
        </member>
        <member name="M:Ict.Common.IO.TYml2Xml.Tag(System.Xml.XmlNode)">
            <summary>
            Tag will move all leafs to a new child element called base
            a leaf is an XmlNode that has no children, only attributes
            all attributes are moved to base
            can only be called once
            todo: what about sequences
            </summary>
            <param name="ANode"></param>
        </member>
        <member name="T:Ict.Common.IO.YamlItemOrderComparer">
            for sorting the controls, depending on Order attribute, and depth
        </member>
        <member name="M:Ict.Common.IO.YamlItemOrderComparer.Compare(System.Xml.XmlNode,System.Xml.XmlNode)">
            required method of IComparer interface
        </member>
        <member name="M:Ict.Common.IO.YamlItemOrderComparer.CompareNodes(System.Xml.XmlNode,System.Xml.XmlNode)">
            <summary>
            compare two nodes; considering base nodes and depth of the node, and the order attribute
            </summary>
            <param name="node1"></param>
            <param name="node2"></param>
            <returns>+1 if node1 is greater than node2, -1 if node1 is less than node2, and 0 if they are the same or identical</returns>
        </member>
    </members>
</doc>
