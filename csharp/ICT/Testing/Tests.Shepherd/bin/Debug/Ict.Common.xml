<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Ict.Common</name>
    </assembly>
    <members>
        <member name="T:Ict.Common.Catalog">
            <summary>
            a helper class for Gnu gettext
            </summary>
        </member>
        <member name="M:Ict.Common.Catalog.Init">
            <summary>
            initialise the resource manager with the default language
            </summary>
        </member>
        <member name="M:Ict.Common.Catalog.Init(System.String,System.String)">
            <summary>
            initialise the resource manager with the given language
            </summary>
        </member>
        <member name="M:Ict.Common.Catalog.SetLanguage(System.String)">
            <summary>
            set the new language
            </summary>
        </member>
        <member name="M:Ict.Common.Catalog.GetString(System.String)">
            <summary>
            get the translated string
            </summary>
        </member>
        <member name="M:Ict.Common.Catalog.GetPluralString(System.String,System.String,System.Int64)">
            <summary>
            Returns the translation of <paramref name="msgid"/> and
            <paramref name="msgidPlural"/>, choosing the right plural form
            depending on the number <paramref name="n"/>.
            </summary>
            <param name="msgid">the key string to be translated, an ASCII
                                string</param>
            <param name="msgidPlural">the English plural of <paramref name="msgid"/>,
                                      an ASCII string</param>
            <param name="n">the number, should be &gt;= 0</param>
            <returns>the translation, or <c>null</c> if none is found</returns>
        </member>
        <member name="T:Ict.Common.NumberToWords">
            <summary>
            This is to write a currency value in words, eg. 123 becomes onehundred twenty-three;
            this has to be implemented for each language.
            see also Java GPL code: NumericalChameleon: http://www.jonelo.de/java/nc/
            </summary>
        </member>
        <member name="M:Ict.Common.NumberToWords.AmountToWords(System.Decimal,System.String,System.String)">
            <summary>
            convert currency amount to words.
            this uses the current culture to determine the language.
            </summary>
            <param name="AValue"></param>
            <param name="ACurrencyName"></param>
            <param name="ACentName"></param>
            <returns></returns>
        </member>
        <member name="T:Ict.Common.TSelfExpandingArrayList">
             <summary>
             A wrapper around System.Collections.ArrayList,
             that allows to use the index property even beyond the existing count of objects
             </summary>
             <example>
              TSelfExpandingArrayList myArray = new TSelfExpandingArrayList();
              myArray[5] = "test5";
              myArray[3] = "test3";
              myArray[7] = "test7";
              for (Int32 i = 0; i &lt; myArray.Count; i++)
              {
                 if (myArray[i] != null)
                 {
                     System.Console.Writeline(i.ToString() + " " + myArray[i].ToString());
                 }
              }
            
              myArray.Compact();
            
              for (Int32 i = 0; i &lt; myArray.Count; i++)
              {
                 if (myArray[i] != null)
                 {
                     System.Console.Writeline(i.ToString() + " " + myArray[i].ToString());
                 }
              }
            </example>
        </member>
        <member name="M:Ict.Common.TSelfExpandingArrayList.Compact">
            <summary>
            remove elements that are not needed anymore
            </summary>
        </member>
        <member name="P:Ict.Common.TSelfExpandingArrayList.Item(System.Int32)">
            <summary>
            property for the elements;
            you can assign elements to any position: the array will be increased
            and filled with null values in between the assigned values
            </summary>
        </member>
        <member name="T:Ict.Common.TCmdOpts">
             <summary>
             This class contains all the commandline parameters. It takes a very easy
             approach for the formatting of commandline parameters that takes values.
             Basically it uses the format &lt;flag&gt;:&lt;value&gt;, eg -F:c:\path\to\file.txt where
             -F is the parameter name, and c:\path\to\file.txt is the value.
             </summary>
             <example>
             if (commandLineOpts.IsFlagSet("hello")) then
             {
                 Console.Writeline(commandLineOpts.GetOptValue("hello"));
             }
            </example>
        </member>
        <member name="F:Ict.Common.TCmdOpts.FList">
            The string list of all the command line options.
        </member>
        <member name="M:Ict.Common.TCmdOpts.#ctor">
            <summary>
            Creates a new object of this class and copies all the parameters that were
            passed on the command line into a string list.
            Uses the array of strings returned by Environment.GetCommandLineArgs
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TCmdOpts.GetOptValue(System.String)">
             <summary>
             Returns the value of the given option.
            
             </summary>
             <param name="AOpt">The option/parameter to look for.</param>
             <returns>The value of the option, or throws an exception if the value was not found
             </returns>
        </member>
        <member name="M:Ict.Common.TCmdOpts.IsFlagSet(System.String)">
            <summary>
            Checks if the given flag is set. <b>Note:</b> Flag can be defined as either
            a standalone flag (eg. --verbose or -v) or can be the name of a parameter
            (eg. -F in -Fc:\path\to\file.txt).
            </summary>
            <param name="flag">Flag to search for in the list of parameters.</param>
            <returns><code>true</code> if flag was set, otherwise <code>false</code>
            </returns>
        </member>
        <member name="P:Ict.Common.TCmdOpts.CommandOptions">
            <summary>
            </summary>
            <returns>The string list of all the command line options.
            </returns>
        </member>
        <member name="T:Ict.Common.TAppSettingsManager">
            <summary>
            The TAppSettingsManager class allows reading of AppSettings section values
            in any .NET Configuration File (not just the one that has the same name as
            the Application itself).
            It also supports parameters on the command line which override the values in the config file.
            </summary>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.UNDEFINEDVALUE">
            <summary>
            constant for undefined value
            </summary>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.FConfigFileName">
            <summary>the path where the application is started from. The name of the Configuration File that should be read from; static so it can be manipulated manually once for all (remoting nunit etc.)</summary>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.FAppSettingsElement">
            <summary>XML Element under which the AppSettings are found</summary>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.Create(System.String,System.Boolean)">
            <summary>
            this should be called by the constructors only;
            in C# one constructor cannot call another constructor, so we have moved the code to a different method
            </summary>
            <param name="CustomConfigFileName">Name of the .NET Configuration File to read from</param>
            <param name="AFailOnMissingConfigFile">if this is true and there is no config file, an exception is raised</param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.#ctor(System.String)">
             <summary>
             Create a TAppSettingsManager that reads AppSettings values from the
             specified .NET Configuration File.
            
             </summary>
             <param name="CustomConfigFileName">Name of the .NET Configuration File to read from
             </param>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.#ctor">
             <summary>
             Create a TAppSettingsManager that reads AppSettings values from the
             Application's standard .NET Configuration File.
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.#ctor(System.Boolean)">
             <summary>
             Create a TAppSettingsManager that reads AppSettings values from the
             Application's standard .NET Configuration File.
            
             </summary>
             <param name="AFailOnMissingConfigFile">if this is true and there is no config file, an exception is raised</param>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.LoadCustomAppSettingFile(System.Boolean)">
             <summary>
             Read AppSetting values from the a .NET Configuration File.
            
             </summary>
             <param name="AFailOnMissingConfigFile">if this is true and there is no config file, an exception is raised; otherwise it returns false</param>
             <returns>TRUE if reading of the .NET Configuration File succeeded.</returns>
             <exception cref="T:System.ApplicationException">Raised when it is not possible to load or
             XML-parse the .NET Configuration File.
             </exception>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.HasValue(System.String)">
            <summary>
            returns true if the value is on the command line or in the config file
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValue(System.String,System.Boolean)">
             <summary>
             Returns the Value of a specified AppSetting key.
            
             </summary>
             <param name="AKey">Key of the AppSetting</param>
             <param name="ALogErrorIfNotPresent"></param>
             <returns>Value of the AppSetting
             </returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValue(System.String)">
            <summary>
            returns the string value of a parameter, either from command line or from the current config file
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>returns the string value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValue(System.String,System.String)">
            <summary>
            returns the string value of a parameter or the default value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="ADefaultValue">the default value in case the parameter cannot be found</param>
            <returns>returns the string value or the default value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt16(System.String,System.Int16)">
            <summary>
            return the Integer value of a parameter or its default value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="ADefaultValue">the default value in case the parameter cannot be found</param>
            <returns>the value of the parameter, or the default value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt16(System.String)">
            <summary>
            read an integer value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>the value of the parameter or -1 if the parameter does not exist on the command line or in the config file</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt32(System.String,System.Int16)">
            <summary>
            return the Integer value of a parameter or its default value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="ADefaultValue">the default value in case the parameter cannot be found</param>
            <returns>the value of the parameter, or the default value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt32(System.String)">
            <summary>
            read an integer value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>the value of the parameter or -1 if the parameter does not exist on the command line or in the config file</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt64(System.String,System.Int16)">
            <summary>
            return the Integer value of a parameter or its default value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="ADefaultValue">the default value in case the parameter cannot be found</param>
            <returns>the value of the parameter, or the default value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetInt64(System.String)">
            <summary>
            read an integer value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>the value of the parameter or -1 if the parameter does not exist on the command line or in the config file</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetFloat(System.String)">
            <summary>
            read a float value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>the value of the parameter or -1.0 if the parameter does not exist on the command line or in the config file</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetBoolean(System.String,System.Boolean)">
            <summary>
            return the Boolean value of a parameter or its default value
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="ADefaultValue">the default value in case the parameter cannot be found</param>
            <returns>the value of the parameter, or the default value</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValueStatic(System.String,System.String,System.Boolean)">
             <summary>
             Returns the Value of a specified AppSetting key.
             This version of the function GetValue will automatically find the correct config file.
             It should only be used for single values, it is quite a bit of overhead to always reload the config file.
            
             </summary>
             <param name="AKey">Key of the AppSetting</param>
             <param name="ADefaultValue">the default value</param>
             <param name="AShowWarning">log a warning if value cannot be found</param>
             <returns>Value of the AppSetting
             </returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValueStatic(System.String)">
            <summary>
            Returns the Value of a specified AppSetting key.
            This version of the function GetValue will automatically find the correct config file.
            It should only be used for single values, it is quite a bit of overhead to always reload the config file.
            </summary>
            <param name="AKey">the name of the parameter</param>
            <returns>value of the parameter, or UNDEFINEDVALUE</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValueStatic(System.String,System.Boolean)">
            <summary>
            Returns the Value of a specified AppSetting key.
            This version of the function GetValue will automatically find the correct config file.
            It should only be used for single values, it is quite a bit of overhead to always reload the config file.
            </summary>
            <param name="AKey">the name of the parameter</param>
            <param name="AShowWarning">log a warning if value cannot be found</param>
            <returns>value of the parameter, or UNDEFINEDVALUE</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetValueStatic(System.String,System.String)">
            <summary>
            Returns the Value of a specified AppSetting key.
            This version of the function GetValue will automatically find the correct config file.
            It should only be used for single values, it is quite a bit of overhead to always reload the config file.
            This overload will log a warning if the value cannot be found.
            </summary>
            <param name="AKey">Key of the AppSetting</param>
            <param name="ADefaultValue">the default value</param>
            <returns>Value of the AppSetting
            </returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.ToBoolean(System.String,System.Boolean)">
             <summary>
             Converts a value given as a string to boolean.
             If the value cannot be interpreted, the default value is returned.
            
             </summary>
             <param name="AValue">the value as a string (true|false|yes|no|0|1)</param>
             <param name="ADefaultValue">default value for the situation that AValue does not have a valid value</param>
             <returns>boolean value
             </returns>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.defaultBoldFont">
            <summary>needed for internationalisation; we cannot hardcode the fonts</summary>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.defaultUIFont">
            <summary>needed for internationalisation; we cannot hardcode the fonts</summary>
        </member>
        <member name="F:Ict.Common.TAppSettingsManager.changeFonts">
            <summary>needed for internationalisation; we cannot hardcode the fonts; this variable defines whether the fonts need to be changed at all</summary>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.ChangeFontForLocalisation">
            <summary>
            needed for internationalisation; for western systems, we don't need to change the fonts
            other systems need different fonts, and also different behaviour (eg. no bold fonts to improve readability)
            </summary>
            <returns>whether the fonts need to be changed for internationalisation</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetDefaultBoldFont">
            <summary>
            needed for internationalisation;
            some languages cannot be displayed in bold letters, because they have so detailed letters
            and the user would not be able to read them in bold letters
            </summary>
            <returns>which font to use for bold letters</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetDefaultBoldFont(System.Single)">
            <summary>
            same as GetDefaultBoldFont, but with option to create the font in a certain size
            </summary>
            <param name="ASize">required size for the font</param>
            <returns>appropriate font for bold letters</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.SetDefaultBoldFont(System.Drawing.Font)">
            <summary>
            Initialise the bold font for the current character setting
            </summary>
            <param name="AFont">the font that should be used for bold characters</param>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.GetDefaultUIFont">
            <summary>
            return the font that should usually be used on the forms
            </summary>
            <returns>appropriate font for general UI</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.SetDefaultUIFont(System.Drawing.Font)">
            <summary>
            set the default font that should be used in general
            </summary>
            <param name="AFont">appropriate font for the current character settings</param>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.ReplaceFont(System.Drawing.Font)">
            <summary>
            test if we need to replace the given font with the default UI font
            </summary>
            <param name="AFont">the font that needs to be evaluated</param>
            <returns>true if this is the default font from the GUI designer, and we want to replace it</returns>
        </member>
        <member name="M:Ict.Common.TAppSettingsManager.InitFontI18N">
            <summary>
            Initialises the font settings by using values from the config file,
            but also checking the Windows environment to find out whether this is a western or asian system
            </summary>
            <returns>the default font to be used</returns>
        </member>
        <member name="P:Ict.Common.TAppSettingsManager.ConfigFileName">
            <summary>
            read only property for the filename of the current config file
            </summary>
        </member>
        <member name="T:Ict.Common.TScreenPartEnum">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="F:Ict.Common.TScreenPartEnum.spAll">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="F:Ict.Common.TScreenPartEnum.spCounters">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TEnableDisableScreenPartsEventHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TRecalculateScreenPartsEventHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TShowTabEventHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TTabPageEventHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TDataSavingStartHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TDataSavedHandler">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TEnableDisableEventArgs">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TEnableDisableEventArgs.#ctor">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TEnableDisableEventArgs.#ctor(System.Boolean)">
            <summary>
            todoComment
            </summary>
            <param name="AEnable"></param>
        </member>
        <member name="P:Ict.Common.TEnableDisableEventArgs.Enable">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TShowTabEventArgs">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TShowTabEventArgs.#ctor">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TShowTabEventArgs.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            todoComment
            </summary>
            <param name="ATabName">todoComment</param>
            <param name="AShow">todoComment</param>
            <param name="AShowNextToTabName">todoComment</param>
        </member>
        <member name="M:Ict.Common.TShowTabEventArgs.#ctor(System.String,System.Boolean)">
            <summary>
            todoComment
            </summary>
            <param name="ATabName">todoComment</param>
            <param name="AShow">todoComment</param>
        </member>
        <member name="P:Ict.Common.TShowTabEventArgs.TabName">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="P:Ict.Common.TShowTabEventArgs.Show">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="P:Ict.Common.TShowTabEventArgs.ShowNextToTabName">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TTabPageEventArgs">
            <summary>
            Event Arguments for the TTabPage Event
            </summary>
        </member>
        <member name="M:Ict.Common.TTabPageEventArgs.#ctor(System.Windows.Forms.TabPage,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="ATabPage">TabPage which this Event is about.</param>
            <param name="AEvent">Event which is happening for the TabPage.</param>
        </member>
        <member name="M:Ict.Common.TTabPageEventArgs.#ctor(System.Windows.Forms.TabPage,System.Windows.Forms.UserControl,System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="ATabPage">TabPage which this Event is about.</param>
            <param name="AUserControlOnTabPage">UserControl which makes up the content of the TabPage (if any).</param>
            <param name="AEvent">Event which is happening for the TabPage.</param>
        </member>
        <member name="F:Ict.Common.TTabPageEventArgs.Tab">
            <summary>
            TabPage which this Event is about.
            </summary>
        </member>
        <member name="F:Ict.Common.TTabPageEventArgs.UserControlOnTabPage">
            <summary>
            UserControl which makes up the content of the TabPage (if any).
            </summary>
        </member>
        <member name="F:Ict.Common.TTabPageEventArgs.Event">
            <summary>
            Event which is happening for the TabPage.
            </summary>
        </member>
        <member name="T:Ict.Common.TRecalculateScreenPartsEventArgs">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="F:Ict.Common.TRecalculateScreenPartsEventArgs.ScreenPart">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TDataSavedEventArgs">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TDataSavedEventArgs.#ctor">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="M:Ict.Common.TDataSavedEventArgs.#ctor(System.Boolean)">
            <summary>
            todoComment
            </summary>
            <param name="ASuccess"></param>
        </member>
        <member name="P:Ict.Common.TDataSavedEventArgs.Success">
            <summary>
            todoComment
            </summary>
        </member>
        <member name="T:Ict.Common.TLoggingType">
            <summary>
            Logging Type describes the destination of the logging messages
            </summary>
        </member>
        <member name="F:Ict.Common.TLoggingType.ToConsole">
            <summary>
            to the console so that you can follow while program is running
            </summary>
        </member>
        <member name="F:Ict.Common.TLoggingType.ToLogfile">
            <summary>
            to log file for later analysis
            </summary>
        </member>
        <member name="F:Ict.Common.TLoggingType.ToStatusBar">
            <summary>
            Statusbar is the alternative for Forms where the user does not have a console
            </summary>
        </member>
        <member name="T:Ict.Common.TLogging">
            <summary>
            The TLogging class provides general logging functionality.
            Logging output can currently go to the Console, to a file or to both at the same time.
            </summary>
        </member>
        <member name="F:Ict.Common.TLogging.DEBUGLEVEL_TRACE">
            <summary>
            the debuglevel that is required for stacktrace to be printed;
            this is related to the mono bug described in the code
            </summary>
        </member>
        <member name="F:Ict.Common.TLogging.DEFAULTUSERNAMEPREFIX">
            <summary>
            this is the default prefix for the username
            </summary>
        </member>
        <member name="F:Ict.Common.TLogging.Context">
             <summary>
             This can provide information about the context of the program situation when a log message is displayed.
             Use SetContext for setting and resetting the context information.
            
             </summary>
        </member>
        <member name="F:Ict.Common.TLogging.StatusBarProcedure">
            <summary>
            This is a procedure that is called with the text as an parameter. It can be used to update a status bar.
            </summary>
        </member>
        <member name="F:Ict.Common.TLogging.StatusBarProcedureValid">
            <summary>
            This is variable indicates if StatusBarProcedure is set to a valid value.
            </summary>
        </member>
        <member name="M:Ict.Common.TLogging.#ctor">
            <summary>
            Creates a Console-only logger.
            </summary>
        </member>
        <member name="M:Ict.Common.TLogging.#ctor(System.String)">
            <summary>
            Creates a logger that can log both to Console or file.
            </summary>
            <param name="AFileName">File to which the output should be written if logging to
            the logfile is requested.</param>
        </member>
        <member name="M:Ict.Common.TLogging.GetLogFileName">
            <summary>
            returns the name of the current log file
            </summary>
            <returns>the path of the current log file</returns>
        </member>
        <member name="M:Ict.Common.TLogging.SetContext(System.String)">
            <summary>
            Set the context of the program situation. It is displayed in the next log messages.
            </summary>
            <param name="context">This will be displayed in the following calls to Log; can be reset with an empty string
            </param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TLogging.SetStatusBarProcedure(Ict.Common.TLogging.TStatusCallbackProcedure)">
             <summary>
             This sets the procedure that is called with the text as an parameter. It can be used to update a status bar.
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TLogging.Log(System.String)">
             <summary>
             Logs a message. Output goes to both Screen and Logfile.
            
             </summary>
             <param name="Text">Log message</param>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TLogging.Log(System.String,Ict.Common.TLoggingType)">
            <summary>
            Logs a message. Output destination can be selected with the Loggingtype
            flag.
            </summary>
            <param name="Text">Log message</param>
            <param name="ALoggingType">Determines the output destination. Note: More than one
            output destination can be chosen!</param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TLogging.LogStackTrace(Ict.Common.TLoggingType)">
            <summary>
            log the current stack trace; it is recommended to use SafeLogStackTrace instead
            </summary>
            <param name="ALoggingtype">destination of logging</param>
        </member>
        <member name="M:Ict.Common.TLogging.Log(System.Collections.ArrayList,System.Boolean)">
            <summary>
            Logs a number of messages in one go. Output goes to both Screen and Logfile.
            </summary>
            <param name="aList">An ArrayList containing a number of Log messages</param>
            <param name="isException">If set to TRUE, an information which states that all
            following Log messages are Exceptions is written before
            the Log messages are logged.</param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TLogging.Log(System.Collections.ArrayList,System.Boolean,Ict.Common.TLoggingType)">
            <summary>
            Logs a number of messages in one go. Output destination can be selected
            with the Loggingtype flag.
            </summary>
            <param name="aList">An ArrayList containing a number of Log messages</param>
            <param name="isException">If set to TRUE, an information which states that all
            following Log messages are Exceptions is written before
            the Log messages are logged.</param>
            <param name="Loggingtype">logging destination (eg. console, logfile etc)</param>
            <returns>void</returns>
        </member>
        <member name="P:Ict.Common.TLogging.UserNamePrefix">
            <summary>
            property for the prefix that describes the
            </summary>
        </member>
        <member name="T:Ict.Common.TLogging.TStatusCallbackProcedure">
            <summary>
            this is used for statusbar updates
            </summary>
        </member>
        <member name="T:Ict.Common.TNoLoggingToFile_WrongConstructorUsedException">
            <summary>
            Thrown when using the wrong constructor
            </summary>
        </member>
        <member name="M:Ict.Common.TNoLoggingToFile_WrongConstructorUsedException.#ctor">
            <summary>
            This Exception is thrown if the TLogging class was created using the Create()
            constructor (without the FileName parameter) and a logging request is made
            that would write to a Logfile.
            </summary>
        </member>
        <member name="T:Ict.Common.TLogWriter">
            <summary>
            The TLogWriter class writes arbitrary strings to a specified log file,
            prefixing them with date and time and optionally also with a prefix.
            Part of the logging framework for ICT Applications.
            </summary>
        </member>
        <member name="M:Ict.Common.TLogWriter.#ctor(System.String)">
            <summary>
            constructor that tells where to write the logfile
            </summary>
            <param name="LogfileName">where to write the logfile</param>
        </member>
        <member name="M:Ict.Common.TLogWriter.GetLogFileName">
            <summary>
            the name of the current logfile
            </summary>
            <returns>the name of the current logfile</returns>
        </member>
        <member name="M:Ict.Common.TLogWriter.Log(System.String,System.String)">
            <summary>
            Log to file
            </summary>
            <param name="strFile">filename of logging file</param>
            <param name="strMessage">message to log</param>
        </member>
        <member name="M:Ict.Common.TLogWriter.Log(System.String)">
            <summary>
            Log message to the current logfile
            </summary>
            <param name="strMessage">message to log</param>
        </member>
        <member name="M:Ict.Common.TLogWriter.Log(System.Collections.ArrayList,System.Boolean)">
            <summary>
            log a list of messages
            </summary>
            <param name="aList">the messages to log</param>
            <param name="isException">if this is an exception, the logging output will look a bit different</param>
        </member>
        <member name="P:Ict.Common.TLogWriter.LogtextPrefix">
            <summary>
            this text is always printed in front of each line in the logging
            can include the current time and user etc
            </summary>
        </member>
        <member name="T:Ict.Common.Networking">
            <summary>
            Contains general networking procedures and functions for ICT Applications.
            </summary>
        </member>
        <member name="M:Ict.Common.Networking.DetermineNetworkConfig(System.String@,System.String@)">
             <summary>
             Examines the network configuration of the computer where this procedure is
             executed.
            
             </summary>
             <param name="ComputerName">Network name of the computer</param>
             <param name="IPAddresses">IP Address(es) of the computer (separated by semicolons if
             there is more than one IP Address for this computer)
             </param>
             <returns>void</returns>
        </member>
        <member name="T:Ict.Common.TRemotingHelper">
            <summary>
            Remoting helper class for ICT applications.
            Allows Interfaces instead of Objects to be used for calls to remote objects
            that are defined in .NET (Remoting) Configuration files.
            see also the book 'Advanced .NET Remoting' (Chapter 4, page 100)
            </summary>
        </member>
        <member name="M:Ict.Common.TRemotingHelper.GetObject(System.Type)">
             <summary>
             Call this function to use interfaces of remote objects that are defined in
             .NET (Remoting) Configuration files.
            
             </summary>
             <param name="MyType">Name of the type as it appears in the .NET (Remoting)
             Configuration file</param>
             <returns>Interface on which calls to the remoted object can be made
             </returns>
        </member>
        <member name="M:Ict.Common.TRemotingHelper.InitTypeCache">
            <summary>
            Initialises a type cache that is used by GetObject.
            </summary>
            <returns>void</returns>
        </member>
        <member name="T:Ict.Common.TSrvSetting">
             <summary>
             Static class for storing Server settings. Once instantiated, Server settings
             can only be read!
             Server Settings are gathered from the Command line, .NET Configuration files
             and other ways (eg. determining the OS on which the server is running
             on-the-fly) at Server start-up.
            
             </summary>
        </member>
        <member name="M:Ict.Common.TSrvSetting.#ctor(System.String,System.String,System.Version,Ict.Common.TExecutingOSEnum,Ict.Common.TDBType,System.String,System.String,System.String,System.String,System.String,System.String,System.Int16,System.Int16,System.String,System.String,System.String,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Boolean,System.String,System.Boolean,System.Boolean,System.String,System.String)">
             <summary>
             Initialises the internal variables that hold the Server Settings.
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ConfigurationFile">
            <summary>Name of .NET Configuration File, if specified via command line options</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ApplicationName">
            <summary>Name of the Server's .exe</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ApplicationVersion">
            <summary>Assembly Version of the Server's .exe</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ExecutingOS">
            <summary>Operating System the Server is running on</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.RDMBSType">
            <summary>Type of RDBMS (Relational Database Management System) that the Server is connected to</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ODBCDsn">
            <summary>ODBC DSN used to connect to the RDBMS</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.DBUsername">
            <summary>Username used to connect to the RDBMS</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.DBPassword">
            <summary>Password used to connect to the RDBMS</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.HostName">
            <summary>Computer name of the Server</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.HostIPAddresses">
            <summary>IP Address(es) of the Server</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.BaseIPAddress">
            <summary>IP Address at which the Server is listening for Client connection/disconnection requests</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.DebugLevel">
            <summary>Debuglevel (can be specified via command line options) [usually only taken into consideration if DEBUGMODE is specified as compiler option for a certain project .dll) of the Server!]</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ServerLogFile">
            <summary>This is the path to the server log file</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.DL">
            <summary>DL is a abbreviated synonym for DebugLevel (more convenient)</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientIdleStatusAfterXMinutes">
            <summary>The amount of time in minutes after which a Client's status is set to 'Idle' when no activity occurs</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientKeepAliveCheckIntervalInSeconds">
            <summary>The interval in seconds in which the PetraServer checks whether the Client made contact</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientKeepAliveTimeoutAfterXSecondsLAN">
            <summary>The amount of time in seconds after which a Client's AppDomain is teared down when no KeepAlive signal was received (LAN connection)</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientKeepAliveTimeoutAfterXSecondsRemote">
            <summary>The amount of time in seconds after which a Client's AppDomain is teared down when no KeepAlive signal was received (Remote connection)</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientConnectionTimeoutAfterXSeconds">
            <summary>The amount of time in seconds after which a Client's attempt to connect to the Server times out</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.ClientAppDomainShutdownAfterKeepAliveTimeout">
            <summary>For debugging purposes only: if set to false, the Client's AppDomain is not teared down when no KeepAlive signal was received (allows to inspect whether all remoted objects are properly released)</summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.PostgreSQLServer">
            <summary>
            the hostname or IP address of the server that is running PostgreSQL for us
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.PostgreSQLServerPort">
            <summary>
            the port of the PostgreSQL server
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.PostgreSQLDatabaseName">
            <summary>
            the name of the PostgreSQL database
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.SMTPServer">
            <summary>
            Which server to use for sending email.
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.AutomaticIntranetExportEnabled">
            <summary>
            A way of turning off Automatic Intranet Export.
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.RunAsStandalone">
            <summary>
            True if PetraServer is running as a server for a Standalone Petra, otherwise false.
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.IntranetDataDestinationEmail">
            <summary>
            Email address that the Intranet Upload Data should get sent to.
            </summary>
        </member>
        <member name="P:Ict.Common.TSrvSetting.IntranetDataSenderEmail">
            <summary>
            Email address of the user that creates the Intranet Upload Data.
            </summary>
        </member>
        <member name="T:Ict.Common.StringHelper">
            <summary>
            General String utility functions for ICT applications.
            </summary>
        </member>
        <member name="M:Ict.Common.StringHelper.InitStrArr(System.String[])">
            <summary>
            convert an array of strings into a StringCollection
            </summary>
            <param name="list">array of strings</param>
            <returns>a new StringCollection containing the strings</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrSplit(System.String,System.String)">
            <summary>
            split a string using a delimiter and return a StringCollection containing the pieces of the string
            </summary>
            <param name="s">the string to split</param>
            <param name="delim">the delimiter to use</param>
            <returns>a StringCollection with the pieces of the string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrMerge(System.Collections.Specialized.StringCollection,System.String)">
            <summary>
            concatenate a string using the given delimiter
            </summary>
            <param name="l">the StringCollection containing the strings that should be concatenated</param>
            <param name="delim">the delimiter to be used between the strings</param>
            <returns>a string with the concatenated strings from the StringCollection</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrMerge(System.String[],System.String)">
            <summary>
            concatenate a string using the given delimiter
            </summary>
            <param name="l">the string array containing the strings that should be concatenated</param>
            <param name="delim">the delimiter to be used between the strings</param>
            <returns>a string with the concatenated strings from the string array</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrSort(System.Collections.Specialized.StringCollection)">
            <summary>
            return a sorted version of the given StringCollection (not case sensitive)
            </summary>
            <param name="l">the StringCollection to be used to generate a sorted list</param>
            <returns>the sorted StringCollection</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.Contains(System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection)">
            <summary>
            check if a StringCollection haystack contains all of the needles
            </summary>
            <param name="haystack">the StringCollection to be searched</param>
            <param name="needles">the StringCollection containing the strings that are to be found</param>
            <returns>true if all strings can be found, false otherwise</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ContainsSome(System.Collections.Specialized.StringCollection,System.Collections.Specialized.StringCollection)">
            <summary>
            check if a StringCollection haystack contains at least one of the needles
            </summary>
            <param name="haystack">the StringCollection to be searched</param>
            <param name="needles">the StringCollection containing the strings that are to be found</param>
            <returns>true if at least one string can be found, false if none can be found</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.IsSame(System.String,System.String)">
            <summary>
            Tests if two strings are equal, case insensitive
            </summary>
            <param name="s1">the first string to be compared</param>
            <param name="s2">the other string to be compared</param>
            <returns>true if the strings are equal, not considering case sensitivity</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.CleanString(System.String)">
            <summary>
            removes line breaks and tabulators and trims spaces, even inside the string
            </summary>
            <param name="s">the string that should be cleaned up</param>
            <returns>the clean string, without line breaks, tabulators and groups of spaces</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.TrimQuotes(System.String)">
            <summary>
            return the string without the quotes at the start and the end of the string
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.StringHelper.FindMatchingQuote(System.String)">
            <summary>
            need to find the matching quotes
            </summary>
            <param name="s">String to the find the matchin quote</param>
            <returns>index of the end matching quote in the string </returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetNextCSV(System.String@,System.String,System.Boolean)">
            <summary>
            retrieves the first value of the comma separated list, and removes the value from the list
            </summary>
            <param name="list">the comma separated list that will get the first value removed</param>
            <param name="separator">the delimiter/separator of the list</param>
            <param name="ATryAllSeparators">if this is true, a number of default separators (slash, comma, etc) will be used</param>
            <returns>the first value of the list</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetNextCSV(System.String@,System.String)">
            <summary>
            overload for GetNextCSV
            this will only use the given separator
            </summary>
            <param name="list">separated values; the first value will be removed</param>
            <param name="separator">delimiter to be used</param>
            <returns>the first value of the string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetNextCSV(System.String@,System.String[])">
            <summary>
            try to use different separators; first fitting separator is used
            </summary>
            <param name="list"></param>
            <param name="separators"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetNextCSV(System.String@)">
            <summary>
            overload for GetNextCSV
            this will use the comma as default separator
            </summary>
            <param name="list">separated values; the first value will be removed</param>
            <returns>the first value of the string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetCSVValue(System.String,System.Int32)">
            <summary>
            retrieves a specific value from a comma separated list, the list stays unchanged
            </summary>
            <param name="list">the comma separated list</param>
            <param name="index">index of the value that should be returned, starting counts with 0</param>
            <returns>the value at the given position in the list</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ContainsCSV(System.String,System.String)">
            <summary>
            checks if the list contains the given value
            </summary>
            <param name="list">separated values</param>
            <param name="AElement">string to look for in the list</param>
            <returns>true if the value is an element of the list</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.AddCSV(System.String,System.String)">
            <summary>
            adds a new value to a comma separated list, adding a comma if necessary
            </summary>
            <param name="line">the existing line, could be empty or hold already values</param>
            <param name="value">the new value</param>
            <returns>the new list, consisting of the old list plus the new value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.AddCSV(System.String,System.String,System.String)">
            <summary>
            adds a new value to a comma separated list, adding a delimiter if necessary
            </summary>
            <param name="line">existing list</param>
            <param name="value">value to be added</param>
            <param name="separator">delimiter to use</param>
            <returns>the new list containing the old list and the new value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ConcatCSV(System.String,System.String,System.String)">
            <summary>
            concatenates two comma separated lists, adding a comma if necessary
            </summary>
            <param name="line1">first line, could be empty or hold already values</param>
            <param name="line2">second line</param>
            <param name="separator">defaults to comma</param>
            <returns>the new list, consisting of the values of the 2 lists</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ConcatCSV(System.String,System.String)">
            <summary>
            concatenate two string using the comma as delimiter
            </summary>
            <param name="line1">the first string</param>
            <param name="line2">the second string</param>
            <returns>a list of the 2 strings</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetNextToken(System.String@)">
            <summary>
            simple parser function
            a token is defined to be a group of characters separated by given separator characters
            eg. a word etc
            </summary>
            <param name="AStringToParse">the string to be parsed; the first token will be removed</param>
            <returns>the first token; skips the separators (eg. spaces)</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DirName(System.String)">
            <summary>
            returns the directory portion of pathname, using the last / or \ character
            </summary>
            <param name="path">the complete path</param>
            <returns>the directory portion of the path</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.BaseName(System.String)">
            <summary>
            returns the filename portion of pathname, using the last / or \ character
            </summary>
            <param name="path">the complete path</param>
            <returns>the filename portion of the path</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.InitialCaps(System.String)">
             <summary>
             Capitalizes the first letter of a string.
             InitialCaps returns a string in which the first character is capitalized and
             all the remaining characters are lower-case.
            
             </summary>
             <param name="str">String to be converted.</param>
             <returns>String formatted with an initial capital.</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.UpperCamelCase(System.String,System.Boolean,System.Boolean)">
            <summary>
            return a string where all underscores are removed,
            and instead the character following the underscore
            has been converted to Uppercase, also the first character of the string
            </summary>
            <param name="AStr">the string to be transformed</param>
            <param name="AIgnorePrefix">strip any prefix</param>
            <param name="AIgnorePostfix">strip any postfix</param>
            <returns>the string in new convention</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.UpperCamelCase(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            General function for transforming a string from old style naming convention to new (e.g. a_account_hierarchy to AccountHierarchy)
            </summary>
            <param name="AStr">string to be transformed</param>
            <param name="ASeparator">separator that will mark the next character for uppercase</param>
            <param name="AIgnorePrefix">should prefixes be ignored</param>
            <param name="AIgnorePostfix">should postfixes be ignored</param>
            <returns>the string in new convention</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.UpperCamelCase(System.String,System.Boolean)">
            <summary>
            overload of UpperCamelCase; will always use the postfix and not drop it
            </summary>
            <param name="AStr">string to be modified</param>
            <param name="AIgnorePrefix">should prefix be ignored</param>
            <returns>converted string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.UpperCamelCase(System.String)">
            <summary>
            overload for UpperCamelCase; will not drop postfix or prefix
            </summary>
            <param name="AStr">string to be changed</param>
            <returns>converted string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ReverseUpperCamelCase(System.String)">
            <summary>
            converts a string from UpperCamelCase back to a string with spaces; keeps the capital letters
            </summary>
        </member>
        <member name="M:Ict.Common.StringHelper.AnsiQuotedStr(System.String,System.String)">
            <summary>
            A Quote character is inserted at the beginning and end of the string, and each Quote character in the string is doubled.
            </summary>
            <param name="s">string to be quoted</param>
            <param name="delim">the quote character to be used (could be single or double quote, etc)</param>
            <returns>the quoted string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.AnsiDeQuotedStr(System.String,System.String)">
            <summary>
            reverse function for AnsiQuotedStr
            this will remove the quotes and deal with quotes contained in the string
            </summary>
            <param name="s">string to be stripped of quotes</param>
            <param name="delim">which quote character to look for and remove/replace</param>
            <returns>the string in non quoted form</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.TryStrToDecimal(System.String,System.Decimal)">
            <summary>
            this method attempts to convert a string to a decimal value;
            if it fails, no exception is thrown, but a default value is used instead
            </summary>
            <param name="s">string that should contain a float</param>
            <param name="ADefault">value to be used if there is no float in the string</param>
            <returns>the decimal value or the default value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.TryStrToInt(System.String,System.Int64)">
            <summary>
            attempt to parse a string for an Integer; if it fails, return a default value
            </summary>
            <param name="s">the string containing an Integer</param>
            <param name="ADefault">alternative default value</param>
            <returns>the Integer value or the default value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.TryStrToInt32(System.String,System.Int32)">
            <summary>
            attempt to parse a string for an Integer; if it fails, return a default value
            </summary>
            <param name="s">the string containing an Integer</param>
            <param name="ADefault">alternative default value</param>
            <returns>the Integer value or the default value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.TryStrToCurr(System.String)">
            <summary>
            attempt to parse a string for an decimal
            this is a little special for currencies, which was more important in Delphi than it is now in C#
            </summary>
            <param name="s">the string containing a currency value</param>
            <returns>the decimal value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.IntToStr(System.Int32)">
            <summary>
            print an integer into a string
            </summary>
            <param name="i">the integer value</param>
            <returns>a string containing the integer value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrToInt(System.String)">
            <summary>
            parse a string and return the Integer value
            </summary>
            <param name="s">the string containing the integer value</param>
            <returns>the integer value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DateToStr(System.DateTime,System.String)">
            <summary>
            print a date into a string using a given format
            this will make sure that the correct separators are used (problem with dash and hyphen in original String.Format)
            </summary>
            <param name="date">the date to be printed</param>
            <param name="format">format string, eg. dd/MM/yyyy; see help for String.Format</param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.StringHelper.PartnerKeyToStr(System.Int64)">
            <summary>
            print a partner key with all leading zeros to a string
            a partner key has the form: 0027123456
            </summary>
            <param name="APartnerKey">partner key to be printed</param>
            <returns>the string containing a formatted version of the partner key</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrToPartnerKey(System.String)">
            <summary>
            parse a string and return the partner key
            </summary>
            <param name="APartnerKeyString">string containing the partner key</param>
            <returns>the Integer value of the partner key</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.FormatStrToPartnerKeyString(System.String)">
            <summary>
            format a partner key given as a string
            will add leading zeros etc
            will rotate the string, so drop a zero at the front in case there is an additional digit at the end
            this is used to help entering the partner key and always display leading zeros
            </summary>
            <param name="APartnerKeyString">the string to be formatted</param>
            <returns>the formatted string containing the partner key</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.IsStringPositiveInteger(System.String)">
            <summary>
            checks if there is positive Integer in the string
            </summary>
            <param name="APositiveInteger">string to check</param>
            <returns>true if greater or equals 0</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.BoolToStr(System.Boolean)">
            <summary>
             print a boolean value to string
            </summary>
            <param name="b">boolean value</param>
            <returns>a string containing the boolean value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.StrToBool(System.String)">
            <summary>
            reverse function for BoolToStr
            will parse a string for a boolean
            </summary>
            <param name="s">string containing the bool value</param>
            <returns>boolean value</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.NullToEmptyString(System.String)">
            <summary>
            makes sure that a null value is converted to an empty string, otherwise the string is returned.
            </summary>
            <param name="s">the string which can be null or have a proper string value</param>
            <returns>empty string or the contents of s</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.FormatCurrencyInternal(System.Decimal,System.String)">
            <summary>
            This method formats a currency value, using an MS Access Style format string.
            examples: "(#,##0.00)" "#,##0.00 CR" etc.
            It returns a string with the written value according to the format.
            This function is only used by FormatCurrency,
            which is the function that should be called from outside.
            </summary>
            <param name="d">the double value to be formatted</param>
            <param name="format">format to be used to print the double</param>
            <returns>the formatted currency string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetFormatString(System.String,System.String)">
            <summary>
            find the appropriate format string, using general format (for the whole column) and the type of the current value
            </summary>
            <param name="AVariantFormatString">what kind of value are we talking about, eg. currency</param>
            <param name="AGeneralFormatString">defining the format on a higher level, e.g. CurrencyWithoutDecimals or CurrencyThousands etc</param>
            <returns>a string format similar to Access string format (format for positive, negative, zero, null)</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.IsCurrencyFormatString(System.String)">
            <summary>
            check if the given format is for currencies
            </summary>
            <param name="AFormatString">format string to check</param>
            <returns>true if the format contains the name currency or characters that are indicating a currency format</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.FormatCurrency(Ict.Common.TVariant,System.String)">
            <summary>
            print a currency value (actually all sorts of values, e.g. dates) into a string
            </summary>
            <param name="value">the value to be printed</param>
            <param name="format">the format to be used; can be dayofyear for birthdays, currency, etc</param>
            <returns>the formatted string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.FormatCurrency(System.Decimal,System.String)">
            <summary>
            overload for FormatCurrency, using a decimal value
            </summary>
            <param name="value">value to be formatted</param>
            <param name="format">format to be used</param>
            <returns>the formatted string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.GetLongMonthName(System.Int32)">
            <summary>
            returns the full name of the month, using .net localised information
            </summary>
            <param name="monthNr">the number of the month (starting January = 1)</param>
            <returns>the printed name of the month</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DateToLocalizedString(System.DateTime)">
            <summary>
            return a string with just the date, no time information
            </summary>
            <param name="ADateTime">the date to print</param>
            <returns>the date printed into a string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DateToLocalizedString(System.Nullable{System.DateTime})">
            <summary>
            overload for nullable DateTime
            </summary>
            <param name="ADateTime"></param>
            <returns></returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DateToLocalizedString(System.DateTime,System.Boolean)">
            <summary>
            return a string with the date and optionally with the time
            </summary>
            <param name="ADateTime">the date to print</param>
            <param name="AIncludeTime">if true then the time is printed as well</param>
            <returns>the printed date</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.DateToLocalizedString(System.DateTime,System.Boolean,System.Boolean)">
            <summary>
            print a date to string, optionally with time and even seconds
            </summary>
            <param name="ADateTime">the date to print</param>
            <param name="AIncludeTime">want to print time</param>
            <param name="ATimeWithSeconds">want to print seconds</param>
            <returns>the formatted date string</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.SetLocalizedMonthNames(System.Collections.ArrayList)">
            <summary>
            initialize the localized month names
            not used at the moment; using .net localisation instead
            </summary>
            <param name="monthNames">an array of the month names</param>
        </member>
        <member name="M:Ict.Common.StringHelper.FindMatchingEndBracket(System.String,System.Int32,System.Char)">
            <summary>
            Finds a matching closing bracket in a String.
            </summary>
            <param name="AInspectString">The String to inspect.</param>
            <param name="AStartPos">Start position from which to search (must be >= 0).</param>
            <param name="ABracketChar">Opening bracket character. Supported are '(', '[' and '{'.</param>
            <returns>If return value is positive: The position in string of the matching closing bracket. If return
            value is negative and not -9999: uneven opening and closing of bracktes. The number is the of missing
            closing brackets. If return value is -9999: AStartPos was greater than the string has characters!</returns>
        </member>
        <member name="M:Ict.Common.StringHelper.ContainsI(System.String,System.String)">
            check if the needle occurs in s, ignoring case sensitivity
        </member>
        <member name="T:Ict.Common.TypeConverter">
            <summary>
            Contains Type-converting classes that inherit from and follow the model of System.ComponentModel.TypeConverter.
            </summary>
        </member>
        <member name="T:Ict.Common.TypeConverter.TDateConverter">
            <summary>
            Converts a date into a common international data format, independent of a computer's date formatting settings.
            </summary>
        </member>
        <member name="T:Ict.Common.TypeConverter.TBooleanToYesNoConverter">
            <summary>
            Converts 'true' and 'false' values to 'Yes' and 'No' values.
            </summary>
            <remarks>TODO: In need of I8N support!</remarks>
        </member>
        <member name="T:Ict.Common.TExecutingCLREnum">
            <summary>
            enum for several runtime environments
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingCLREnum.eclrUnknown">
            <summary>
            unknown
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingCLREnum.eclrMicrosoftDotNetFramework">
            <summary>
            Microsoft .Net
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingCLREnum.eclrMono">
            <summary>
            Mono
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingCLREnum.eclrDotGNUPortableNet">
            <summary>
            DotGnu (not really supported)
            </summary>
        </member>
        <member name="T:Ict.Common.TNullHandlingEnum">
            <summary>
            enum for handling date values that are null
            </summary>
        </member>
        <member name="F:Ict.Common.TNullHandlingEnum.nhReturnLowestDate">
            <summary>
            lowest possible date
            </summary>
        </member>
        <member name="F:Ict.Common.TNullHandlingEnum.nhReturnHighestDate">
            <summary>
            highest possible date
            </summary>
        </member>
        <member name="T:Ict.Common.TExecutingOSEnum">
            <summary>
            enum for the Operating System that this program is running on
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingOSEnum.eosLinux">
            <summary>
            Linux
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingOSEnum.eosWin98ToWinME">
            <summary>
            Win98 up to Windows Millenium (not really supported)
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingOSEnum.eosWinNTOrLater">
            <summary>
            Windows NT and later
            </summary>
        </member>
        <member name="F:Ict.Common.TExecutingOSEnum.oesUnsupportedPlatform">
            <summary>
            unknown and unsupported
            </summary>
        </member>
        <member name="T:Ict.Common.TDBType">
            <summary>
            Type of RDBMS (Relational Database Management System)
            </summary>
        </member>
        <member name="F:Ict.Common.TDBType.PostgreSQL">
            <summary>The PostgreSQL RDBMS</summary>
        </member>
        <member name="F:Ict.Common.TDBType.MySQL">
            <summary>The MySQL RDBMS</summary>
        </member>
        <member name="F:Ict.Common.TDBType.ProgressODBC">
            <summary>Using ODBC to access legacy Progress databases</summary>
        </member>
        <member name="F:Ict.Common.TDBType.SQLite">
            <summary>For standalone and demo system, SQLite</summary>
        </member>
        <member name="T:Ict.Common.TDataModeEnum">
            <summary>
            several modes a data edit screen can be in
            </summary>
        </member>
        <member name="F:Ict.Common.TDataModeEnum.dmBrowse">
            <summary>
            just browsing the data, viewing, read only
            </summary>
        </member>
        <member name="F:Ict.Common.TDataModeEnum.dmEdit">
            <summary>
            edit the data
            </summary>
        </member>
        <member name="F:Ict.Common.TDataModeEnum.dmAdd">
            <summary>
            add new data
            </summary>
        </member>
        <member name="T:Ict.Common.TClientServerConnectionType">
            <summary>
            enum for the connection between client and server
            </summary>
        </member>
        <member name="F:Ict.Common.TClientServerConnectionType.csctLAN">
            <summary>
            inside a LAN network (quite fast)
            </summary>
        </member>
        <member name="F:Ict.Common.TClientServerConnectionType.csctRemote">
            <summary>
            remote through VPN, can be slow
            </summary>
        </member>
        <member name="F:Ict.Common.TClientServerConnectionType.csctLocal">
            <summary>
            standalones run the client and the server on one machine
            </summary>
        </member>
        <member name="T:Ict.Common.TAsyncExecProgressState">
            <summary>
            enum for states in the asynchronous execution
            </summary>
        </member>
        <member name="F:Ict.Common.TAsyncExecProgressState.Aeps_ReadyToStart">
            <summary>
            read to start
            </summary>
        </member>
        <member name="F:Ict.Common.TAsyncExecProgressState.Aeps_Executing">
            <summary>
            currently running
            </summary>
        </member>
        <member name="F:Ict.Common.TAsyncExecProgressState.Aeps_Finished">
            <summary>
            finished
            </summary>
        </member>
        <member name="F:Ict.Common.TAsyncExecProgressState.Aeps_Stopping">
            <summary>
            is stopping at the moment
            </summary>
        </member>
        <member name="F:Ict.Common.TAsyncExecProgressState.Aeps_Stopped">
            <summary>
            stopped
            </summary>
        </member>
        <member name="T:Ict.Common.TSubmitChangesResult">
            <summary>
            different states when submitting some data to the server
            </summary>
        </member>
        <member name="F:Ict.Common.TSubmitChangesResult.scrOK">
            <summary>
            submission was ok, data has been saved to database
            </summary>
        </member>
        <member name="F:Ict.Common.TSubmitChangesResult.scrError">
            <summary>
            there has been an error during submission
            </summary>
        </member>
        <member name="F:Ict.Common.TSubmitChangesResult.scrNothingToBeSaved">
            <summary>
            there is no new data, therefore nothing needs to be written to the database
            </summary>
        </member>
        <member name="F:Ict.Common.TSubmitChangesResult.scrInfoNeeded">
            <summary>
            more info (user interaction) needed, before saving of data is possible
            </summary>
        </member>
        <member name="T:Ict.Common.TSearchCriteria">
            <summary>
            search criteria for SQL queries
            </summary>
        </member>
        <member name="F:Ict.Common.TSearchCriteria.comparator">
            <summary>
            how to compare; defaults to equals
            </summary>
        </member>
        <member name="F:Ict.Common.TSearchCriteria.fieldname">
            <summary>
            field to compare
            </summary>
        </member>
        <member name="F:Ict.Common.TSearchCriteria.searchvalue">
            <summary>
            which value to search for
            </summary>
        </member>
        <member name="M:Ict.Common.TSearchCriteria.#ctor(System.String,System.Object)">
            <summary>
            constructor
            </summary>
            <param name="AFieldName"></param>
            <param name="ASearchValue"></param>
        </member>
        <member name="T:Ict.Common.IInterface">
             <summary>
             Surrogate Base Interface
             All Interfaces can safely derive from this Interface. The reason why we have this is:
             that all Types that implement any Interfaces that themselves derives from IInterface
             can be cast to IInterface (and passed as Function Argument: eg. IInterface AnObject).
             This is important for .NET Remoting scenarios.
            
             </summary>
        </member>
        <member name="T:Ict.Common.CommonTypes">
            <summary>
            some functions that are useful for operating with the enums defined in Ict.Common
            </summary>
        </member>
        <member name="M:Ict.Common.CommonTypes.ParseDBType(System.String)">
            <summary>
            convert the string to the enum for the RDBMS System
            </summary>
            <param name="ADBType">defines the chosen database system</param>
            <returns>enum value</returns>
        </member>
        <member name="M:Ict.Common.CommonTypes.ExecutingOSEnumToString(Ict.Common.TExecutingOSEnum)">
            <summary>
            convert the enum to string for the Operating System
            </summary>
            <param name="AExecutingOS">defines the operating system</param>
            <returns>string representing the operating system</returns>
        </member>
        <member name="M:Ict.Common.CommonTypes.ExecutingOSEnumToString(Ict.Common.TExecutingOSEnum,System.Boolean)">
            <summary>
            convert the enum to string for the Operating System
            </summary>
            <param name="AExecutingOS">defines the operating system</param>
            <param name="ALongDescription">we want a long description of the OS</param>
            <returns>string representing the operating system</returns>
        </member>
        <member name="T:Ict.Common.EDBConcurrencyException">
            <summary>
            Thrown by classes in the DataStore if the record that is beeing written to the DB has modifications by another user
            </summary>
        </member>
        <member name="F:Ict.Common.EDBConcurrencyException.FDBOperation">
            <summary>'write' or 'delete'</summary>
        </member>
        <member name="F:Ict.Common.EDBConcurrencyException.FDBTable">
            <summary>eg. 'p_partner'</summary>
        </member>
        <member name="F:Ict.Common.EDBConcurrencyException.FLastModificationUser">
            <summary>eg. 'SYSADMIN'</summary>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyException.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="msg">Message</param>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyException.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            constructor for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyException.#ctor(System.String,System.String,System.String,System.String,System.DateTime)">
            <summary>
            constructor
            </summary>
            <param name="msg">Message</param>
            <param name="ADBOperation">reading or writing</param>
            <param name="ADBTable">which table is involved</param>
            <param name="ALastModificationUser">who has changed last</param>
            <param name="ALastModification">when was the last change</param>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            create a serializable paket
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="P:Ict.Common.EDBConcurrencyException.DBOperation">
            <summary>
            write or delete
            </summary>
        </member>
        <member name="P:Ict.Common.EDBConcurrencyException.DBTable">
            <summary>
            table that causes the problems
            </summary>
        </member>
        <member name="P:Ict.Common.EDBConcurrencyException.LastModificationUser">
            <summary>
            who changed it last?
            </summary>
        </member>
        <member name="P:Ict.Common.EDBConcurrencyException.LastModification">
            <summary>
            when was it changed last?
            </summary>
        </member>
        <member name="T:Ict.Common.EDBConcurrencyRowDeletedException">
             <summary>
             Specialisation of EDBConcurrencyException - this is thrown if a record should
             be updated, but it isn't there anymore in the DB!
            
             </summary>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyRowDeletedException.#ctor(System.String,System.String,System.String,System.String,System.DateTime)">
            <summary>
            constructor
            </summary>
            <param name="msg">Message</param>
            <param name="ADBOperation">reading or writing</param>
            <param name="ADBTable">which table is involved</param>
            <param name="ALastModificationUser">who changed it last</param>
            <param name="ALastModification">when was the last change</param>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyRowDeletedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            constructor for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="M:Ict.Common.EDBConcurrencyRowDeletedException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="T:Ict.Common.EPartnerKeyOutOfRangeException">
             <summary>
             This Class has no new functionality  it just exists to be able to differntiate what kind of concurrency Exception is occuring!
             Raise this Exception when a the PartnerKey number does not fit into a string
             of Length 10.
            
             </summary>
        </member>
        <member name="M:Ict.Common.EPartnerKeyOutOfRangeException.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.EPartnerKeyOutOfRangeException.#ctor(System.String)">
            <summary>
            constructor
            </summary>
            <param name="AMessage">Message</param>
        </member>
        <member name="M:Ict.Common.EPartnerKeyOutOfRangeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            constructor for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="M:Ict.Common.EPartnerKeyOutOfRangeException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="T:Ict.Common.EDBSubmitException">
             <summary>
             Raise this Exception when a DB INSERT, UPDATE or DELETE query failed and the caller
             should be informed about that.
            
             </summary>
        </member>
        <member name="M:Ict.Common.EDBSubmitException.#ctor">
            <summary>
            constructor
            </summary>
        </member>
        <member name="M:Ict.Common.EDBSubmitException.#ctor(System.String,System.Data.Odbc.OdbcException)">
            <summary>
            constructor
            </summary>
            <param name="AMessage">Message</param>
            <param name="AExp">the odbc exception</param>
        </member>
        <member name="M:Ict.Common.EDBSubmitException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            constructor for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="M:Ict.Common.EDBSubmitException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            for serialization
            </summary>
            <param name="info">for serialization</param>
            <param name="context">for serialization</param>
        </member>
        <member name="T:Ict.Common.TSaveConvert">
            <summary>
            some static methods for the save conversion of dates to objects and objects to dates
            </summary>
        </member>
        <member name="M:Ict.Common.TSaveConvert.ObjectToDate(System.Object)">
             <summary>
             Converts a date value that is stored in a TObject to a DateTime value that is
             guaranteed to be valid.
            
             In case the date value in the TObject is empty, the lowest possible date
             is returned.
            
             @comment Very useful for untyped data in DataSets that is known to be of
             DateTime type.
            
             </summary>
             <param name="ADateObject">TObject containing a date value</param>
             <returns>A valid DateTime
             </returns>
        </member>
        <member name="M:Ict.Common.TSaveConvert.ObjectToDate(System.Object,Ict.Common.TNullHandlingEnum)">
             <summary>
             Converts a date value that is stored in a TObject to a DateTime value that is
             guaranteed to be valid.
            
             In case the date value in the TObject is empty, either the lowest or the
             highest possible date is returned.
            
             @comment Very useful for untyped data in DataSets that is known to be of
             DateTime type.
            
             </summary>
             <param name="ADateObject">TObject containing a date value</param>
             <param name="ANullHandling">Switch to return either the lowest (nhReturnLowestDate)
             or the highest (nhReturnHighestDate) possible date in case the date value
             in the TObject is empty</param>
             <returns>A valid DateTime
             </returns>
        </member>
        <member name="M:Ict.Common.TSaveConvert.DateColumnToDate(System.Data.DataColumn,System.Data.DataRow)">
             <summary>
             Converts a DataColumn that holds a DateTime into a DateTime that is
             guaranteed to be valid.
            
             In case the date value in the DataColumn is DBNull, the lowest possible date
             is returned.
            
             @comment Very useful for DataColumns in Typed DataTables that are of DateTime
             type. Using this function, no Exception is thrown when trying to get the
             value of a DataColumn of Type DateTime that is DBNull.
            
             </summary>
             <param name="ADataColumn">DataColumn of Type DateTime</param>
             <param name="ADataRow">DataRow in which the value is found</param>
             <returns>A valid DateTime
             </returns>
        </member>
        <member name="M:Ict.Common.TSaveConvert.DateColumnToDate(System.Data.DataColumn,System.Data.DataRow,Ict.Common.TNullHandlingEnum)">
             <summary>
             Converts a DataColumn that holds a DateTime into a DateTime that is
             guaranteed to be valid.
            
             In case the date value in the DataColumn is DBNull, the lowest possible date
             is returned.
            
             @comment Very useful for DataColumns in Typed DataTables that are of DateTime
             type. Using this function, no Exception is thrown when trying to get the
             value of a DataColumn of Type DateTime that is DBNull.
            
             </summary>
             <param name="ADataColumn">DataColumn of Type DateTime</param>
             <param name="ADataRow">DataRow in which the value is found</param>
             <param name="ANullHandling">Switch to return either the lowest (nhReturnLowestDate)
             or the highest (nhReturnHighestDate) possible date in case the date value
             in the TObject is empty</param>
             <returns>A valid DateTime
             </returns>
        </member>
        <member name="M:Ict.Common.TSaveConvert.StringColumnToString(System.Data.DataColumn,System.Data.DataRow)">
             <summary>
             Converts a DataColumn that holds a String into a String that is guaranteed
             to be valid.
            
             In case the String value in the DataColumn is DBNull, an empty String ('')
             is returned.
            
             @comment Very useful for DataColumns in Typed DataTables that are of String
             type. Using this function, no Exception is thrown when trying to get the
             value of a DataColumn of Type String that is DBNull.
            
             </summary>
             <param name="ADataColumn">DataColumn of Type DateTime</param>
             <param name="ADataRow">DataRow in which the value is found</param>
             <returns>A valid String
             </returns>
        </member>
        <member name="T:Ict.Common.Attributes">
            <summary>
             this class contains some attribute classes (at the moment only one)
            </summary>
        </member>
        <member name="T:Ict.Common.Attributes.ResourceStringAttribute">
            <summary>
            This custom .NET Attribute is used to mark functions that return resourcestrings.
            These Attributes can later be found and the functions can be changed to return
            resourcestrings from any source/repository instead of having them hardcoded in code.
            </summary>
        </member>
        <member name="M:Ict.Common.Attributes.ResourceStringAttribute.#ctor(System.String,System.String)">
            <summary>
            This constructor defines two required parameters.
            </summary>
            <param name="AResourceStringName"></param>
            <param name="AResourceNamespace"></param>
        </member>
        <member name="P:Ict.Common.Attributes.ResourceStringAttribute.ResourceStringName">
            <summary>
            Define Name property.
            This is a read-only attribute.
            </summary>
        </member>
        <member name="P:Ict.Common.Attributes.ResourceStringAttribute.ResourceNamespace">
            <summary>
            Define ResourceNamespace property.
            This is a read-only attribute.
            </summary>
        </member>
        <member name="P:Ict.Common.Attributes.ResourceStringAttribute.Translated">
            <summary>
            Define Translated property.
            This is a read/write attribute.
            </summary>
        </member>
        <member name="T:Ict.Common.Utilities">
            <summary>
            General utility functions for ICT applications that don't fall into other
            Units of the Ict.Common namespace.
            </summary>
        </member>
        <member name="M:Ict.Common.Utilities.CurrentTime">
             <summary>
             Shorthand function that returns the current time in the HH:mm:ss format
             (24 hrs).
            
             </summary>
             <returns>String containing the formatted current time.
             </returns>
        </member>
        <member name="M:Ict.Common.Utilities.DetermineExecutingOS">
             <summary>
             Determines the Operating System on which this function is executed.
            
             </summary>
             <returns>A value of the TExecutingOS enumeration.</returns>
        </member>
        <member name="M:Ict.Common.Utilities.DetermineExecutingCLR">
            <summary>
            this discovers if we are running on Microsoft .net or Mono etc
            Common Language Runtime
            </summary>
            <returns>the runtime environment for .net</returns>
        </member>
        <member name="M:Ict.Common.Utilities.AddToArray(System.Object[],System.Object)">
            <summary>
            add a value to an existing array
            this will create a new array and copy all the elements and add the new value
            </summary>
            <param name="currentArray">existing array</param>
            <param name="newValue">new value</param>
            <returns>a new array with old values and the new value</returns>
        </member>
        <member name="T:Ict.Common.eVariantTypes">
            <summary>
            enum for the supported data types in the TVariant class
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eEmpty">
            <summary>
            no value at all
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eDateTime">
            <summary>
            date/time
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eDecimal">
            <summary>
            decimal
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eCurrency">
            <summary>
            currency (decimal, but with 2 fixed decimals)
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eInteger">
            <summary>
            integer
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eInt64">
            <summary>
            long integer
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eString">
            <summary>
            string
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eBoolean">
            <summary>
            boolean
            </summary>
        </member>
        <member name="F:Ict.Common.eVariantTypes.eComposite">
            <summary>
            composite: several TVariants concatenated
            </summary>
        </member>
        <member name="T:Ict.Common.TVariant">
            <summary>
             a class for the storage of values in different representations;
            Conversion functions are provided.
            </summary>
        </member>
        <member name="M:Ict.Common.TVariant.StripDecimalAndZeros(System.String)">
            <summary>
            remove all trailing zeros, and the decimal point, if there are no decimals left
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="F:Ict.Common.TVariant.TypeVariant">
            <summary>
            the type of the value stored in this instance
            </summary>
        </member>
        <member name="F:Ict.Common.TVariant.FormatString">
            <summary>for currencies and dayofyear (date)</summary>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Object)">
            <summary>
            constructor from any object
            </summary>
            <param name="value">any type of object</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(Ict.Common.TVariant)">
            <summary>
            copy constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.DateTime,System.String)">
             <summary>
             constructor for dates
             </summary>
             <param name="value">date time value</param>
             <param name="AFormat">can be dayofyear (for birthdays)</param>
             <returns>void</returns>
            
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.DateTime)">
            <summary>
            constructor for dates
            </summary>
            <param name="value">date time value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Decimal,System.String)">
            <summary>
            constructor for decimal
            </summary>
            <param name="value">decimal value</param>
            <param name="AFormat">requested format</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Decimal)">
            <summary>
            constructor for decimal
            </summary>
            <param name="value">decimal value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Double)">
            <summary>
            constructor for double (will be converted to decimal)
            </summary>
            <param name="value">double value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Char)">
            <summary>
            constructor for single characters
            </summary>
            <param name="value">character value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Int32)">
            <summary>
            constructor for integer
            </summary>
            <param name="value">integer value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Int64)">
            <summary>
            constructor for long integer
            </summary>
            <param name="value">long integer value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.String,System.String)">
            <summary>
            constructor for string
            will look at the content of the string and generate a typed representation
            if you want to force a string value, use the other overloaded constructor below
            </summary>
            <param name="value">string value</param>
            <param name="AFormat">requested format</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.String)">
            <summary>
            constructor for string
            </summary>
            <param name="value">string value</param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.String,System.Boolean)">
            <summary>
            constructor for string
            if you want the content to be kept as a string, and not converted to int (e.g. cost centre: 0200)
            </summary>
            <param name="value"></param>
            <param name="ExplicitString"></param>
        </member>
        <member name="M:Ict.Common.TVariant.#ctor(System.Boolean)">
            <summary>
            constructor for boolean
            </summary>
            <param name="value">boolean value</param>
        </member>
        <member name="M:Ict.Common.TVariant.Add(Ict.Common.TVariant,System.String,System.Boolean)">
             <summary>
             This either adds the new value to an already existing composite (list of several values),
             or it changes the current non composite variable to be a composite,
             by adding the current value as the first member to the list, and then adding the new value;
             ToString will concatenate the values, but ToDecimal, ToBoolean etc will only convert the first value in the composite
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.Add(Ict.Common.TVariant,System.String)">
            <summary>
            overload for Add
            </summary>
            <param name="value">value to be added</param>
            <param name="AFormatString">requested format for the value</param>
        </member>
        <member name="M:Ict.Common.TVariant.Add(Ict.Common.TVariant)">
            <summary>
            overload for Add
            </summary>
            <param name="value">value to be added</param>
        </member>
        <member name="M:Ict.Common.TVariant.FirstCompositeValue">
            <summary>
            returns the first value of the list, or an empty value, if the list is empty
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.DecodeFromString(System.String)">
             <summary>
             This static function is used to create a variant with the correct type,
             when the variant is restored from an encoded string,
             that could e.g. be stored in a datatable (only strings)
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.EncodeToString">
             <summary>
             This function creates an encoded string, that holds the value and the type
            
             </summary>
             <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.Assign(Ict.Common.TVariant)">
            <summary>
            copy the value to the current object instance
            </summary>
            <param name="value">value to be copied</param>
        </member>
        <member name="M:Ict.Common.TVariant.ToObject">
            <summary>
            Convert TVariant to Object
            </summary>
            <returns>a representation of this TVariant instance as a typed Object</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToInt">
            <summary>
            convert to Integer
            </summary>
            <returns>an integer representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToInt32">
            <summary>
            convert to Integer
            </summary>
            <returns>an integer representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToInt64">
            <summary>
            convert to Integer
            </summary>
            <returns>an integer representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToBool">
            <summary>
            convert to Boolean
            </summary>
            <returns>a boolean representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToDouble">
            <summary>
            convert to Double
            </summary>
            <returns>a double representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToDecimal">
            <summary>
            convert to Decimal
            </summary>
            <returns>a decimal representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToComposite">
            <summary>
            convert to list of TVariant
            </summary>
            <returns>an array of TVariant</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToString">
            <summary>
            will call ToString(false),
            which means it will not print "NOTFOUND" for an empty value,
            for debugging call toString(true)
            </summary>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToString(System.Boolean)">
            <summary>
            print to string
            </summary>
            <param name="printNotFound">print something so that it is clear that the value was invalid</param>
            <returns>a string representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToDate">
            <summary>
            convert to Date
            </summary>
            <returns>a date representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.DateToString(System.String)">
            <summary>
            print date to string
            </summary>
            <param name="format">the requested format to be used</param>
            <returns>a string representation</returns>
        </member>
        <member name="M:Ict.Common.TVariant.CurrencyToFormattedString(System.String,System.String)">
            <summary>
            format a currency value and print to string
            </summary>
            <param name="ACurrencyFormat">which format to use</param>
            <param name="AOutputType">print to CSV, or for localised output</param>
            <returns>a string with the formatted date</returns>
        </member>
        <member name="M:Ict.Common.TVariant.CurrencyToFormattedString(System.String)">
            <summary>
            overload for CurrencyToFormattedString, for localized output
            </summary>
            <param name="ACurrencyFormat">which format to use</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToFormattedString(System.String,System.String)">
            <summary>
            Format the current value to be exported to CSV or to be printed with the local culture format settings (for currencies and dates);
            </summary>
            <param name="ACurrencyFormat">CurrencyThousands or CurrencyWithoutDecimals</param>
            <param name="AOutputType">Localized or CSV
            </param>
            <returns>void</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToFormattedString(System.String)">
            <summary>
            overload of ToFormattedString
            </summary>
            <param name="ACurrencyFormat">format to use</param>
            <returns>formatted string</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ToFormattedString">
            <summary>
            overload of ToFormattedString
            </summary>
            <returns>formatted string</returns>
        </member>
        <member name="M:Ict.Common.TVariant.ApplyFormatString(System.String)">
            <summary>
            apply the string format to the current variable
            </summary>
            <param name="AFormatString">format to be used</param>
        </member>
        <member name="M:Ict.Common.TVariant.IsZeroOrNull">
            <summary>
            evaluate if the current value is zero or null
            </summary>
            <returns>s true if the value is empty or has an empty string or 0 or 0.0</returns>
        </member>
        <member name="M:Ict.Common.TVariant.IsNil">
            <summary>
            check if the value is empty
            </summary>
            <returns>s true if the value is empty</returns>
        </member>
        <member name="M:Ict.Common.TVariant.CompareTo(Ict.Common.TVariant)">
            <summary>
            </summary>
            <returns>s 0 if equal, -1 if this object is less than the parameter, +1 if it is greater
            </returns>
        </member>
        <member name="M:Ict.Common.TVariant.CompareToI(Ict.Common.TVariant)">
            <summary>
            compare case insenstive
            </summary>
            <param name="v"></param>
            <returns></returns>
        </member>
    </members>
</doc>
