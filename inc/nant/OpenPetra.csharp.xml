<?xml version="1.0"?>
<project name="OpenPetra-csharp">

<include buildfile="OpenPetra.default.targets.xml"/>


<include buildfile="OpenPetra.references.xml"/>

<property name="RunCsDepend" value="true" overwrite="false"/>
<property name="CsDependAdditionalLibReferences" value="" overwrite="false"/> 
<property name="OutputType" value="library" overwrite="false"/>
<property name="csc-ouput-ext" value="dll" if="${OutputType=='library'}" />
<property name="csc-ouput-ext" value="exe" unless="${OutputType=='library'}" />
<property name="AssemblyName" value="${Namespace}.${csc-ouput-ext}" />
<property name="namespace-temp-dir" value="${path::combine(tempdir,Namespace)}" />
<property name="AssemblyNameInfo.cs" value="${path::combine(namespace-temp-dir,'AssemblyInfo.cs')}" />
<property name="referencesFile" value="${path::combine(namespace-temp-dir,Namespace+'.generated.refs')}" />
<property name="resourcefiles" value="*.resx"  overwrite="false"/>
<property name="compilefiles" value="*.cs"  overwrite="false"/>
<property name="csdependfiles" value="**/*.cs"  overwrite="false"/>
<property name="excludecsfiles" value=".doc"  overwrite="false"/>
<property name="DebugStartArguments" value="" overwrite="false"/>


<target name="uncrustify" depends="indent" 
        description="indent the code, so it adheres the formatting guidelines" />

<target name="indent" depends="" description="indent the code, so it adheres the formatting guidelines. Use nant -D:files=filename indent">
  <if test="${not property::exists('files')}">
  <!-- set all files as default -->
    <property name="files" value="" />
    <foreach item="File" property="filename" trim="Both">
      <in><items><include name="**.cs" /></items></in>
      <do><property name="files" value="${files},&quot;${filename}&quot;" /></do>
    </foreach>
  </if>
  <property name="files" value="${string::trim(files)}" />
  <echo level="Debug">files='${files}'</echo>
  <foreach item="String" in="${files}" delim="," trim="Both" property="filename"><do>
    <if test="${0!=string::get-length(filename)}">
      <if test="${not OP::IsAutoGeneratedFile(filename)}">
      <echo message="Indent ${filename}:"/>
        <exec program="${external.Uncrustify}" workingdir="${project::get-base-directory()}" resultproperty="rc"> 
          <arg value="-c" />
          <arg value="${dir.incdir.cfg}/uncrustify-petra.cfg" />
          <arg value="--no-backup" />
          <arg value="${filename}" />
        </exec>
      </if>
    </if>
  </do></foreach>
</target>

<if test="${not target::exists('custclean')}">
  <include buildfile="OpenPetra.target-custclean.xml"/>
</if>

<target name="clean" depends="custclean">
  <if test="${not property::exists('called-nant-subcall')}">
    <if test="${file::exists(referencesFile)}">
      <include buildfile="${referencesFile}" />
      <property name="target" value="clean" />
      <property name="called-nant-subcall" value="true" />
      <call target="nant-subcall" cascade="false" />
    </if>
    <delete>
      <fileset>
        <include name="${dir.bin}/${AssemblyName}" asis="true" />
        <include name="${dir.bin}/${Namespace}.xml" asis="true" />
        <include name="${dir.bin}/${Namespace}.pdb" asis="true" />
        <include name="${path::combine(dir.namespace.map, Namespace + '.namespace-map')}" />        
      </fileset>
    </delete>
    <delete dir="${namespace-temp-dir}" />
    <if test="${bool::parse(RunCsDepend)}" >
      <!-- Only delete the files, if they were generated by this nant file -->
      <delete><fileset>
          <include name="**/*-generated.build" />
      </fileset></delete>
    </if>
  </if>
</target>

<if test="${not target::exists('custdepend')}">
  <include buildfile="OpenPetra.target-custdepend.xml"/>
</if>

<target name="depend" depends="custdepend">
  <if test="${true==bool::parse(RunCsDepend)}">
    <mkdir dir="${namespace-temp-dir}" />
    <mkdir dir="${dir.namespace.map}" />
    <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('CsDepend')}"/>
    <CsDepend ns-default="${Namespace}" ns-map-dir="${dir.namespace.map}" 
      basedir="${project::get-base-directory()}" uuidfile="${uuidFile}"
      referencesfile="${referencesFile}" buildincfile="${path::combine(dir.buildfiles, 'OpenPetra.csharp.xml')}"
      templatefile="${path::combine(dir.root,'inc/nanttasks/CsDependTemplates.txt')}" 
      additionalRefs="${CsDependAdditionalLibReferences}" outputtype="${OutputType}" >
      <sources>
        <include name="${csdependfiles}" />
        <exclude name="${excludecsfiles}" />
      </sources>    
    </CsDepend>
  </if>
  <call target="setreferences" />
</target>

<target name="setreferences" depends="">
  <if test="${true==bool::parse(RunCsDepend)}">
    <include buildfile="${referencesFile}" />
  </if>
  <!-- the dll files must actually exist, otherwise they are not considered by NAnt in the fileset -->
  <assemblyfileset id="assemblyfileset-references" basedir="${dir.bin}">
    <lib>
      <include name="${dir.bin}"/>
    </lib>
    <patternset refid="references" />
    <patternset refid="csharpStdLibs" />
  </assemblyfileset>
</target>

<target name="compile" depends="depend">
  <!-- Create assembly info -->
  <if test="${bool::parse(RunCsDepend)!=true}">
    <mkdir dir="${namespace-temp-dir}" />
    <mkdir dir="${dir.bin}" />
    <asminfo output="${AssemblyNameInfo.cs}" language="CSharp">
      <imports>
        <import namespace="System.Reflection" />
        <import namespace="System.Runtime.CompilerServices" />
        <import namespace="System.Runtime.InteropServices" />
      </imports>
      <attributes>
        <attribute type="AssemblyTitle" value='"${Namespace}"' asis="true" />
        <attribute type="AssemblyDescription" value='""' asis="true" />
        <attribute type="AssemblyConfiguration" value='""' asis="true" />
        <attribute type="AssemblyCompany" value='"${info.assembly.company}"' asis="true" />
        <attribute type="AssemblyProduct" value='"${info.productname}"' asis="true" />
        <attribute type="AssemblyCopyright" value='"${info.assembly.copyright}"' asis="true" />
        <attribute type="AssemblyTrademark" value='""' asis="true" />
        <attribute type="AssemblyCulture" value='""' asis="true" />       
        <attribute type="ComVisible" value="false" asis="true" /> 
        <attribute type="AssemblyVersion" value='"${ReleaseID}"' asis="true" /> 
      </attributes>
    </asminfo>
    <if test="${not file::exists(dir.bin + '/dont_compile.txt')}">
      <!-- filealign="4096"  for csc not supported on mono -->
      <csc output="${dir.bin}/${AssemblyName}" 
           doc="${dir.bin}/${Namespace}.xml"
           target="${OutputType}" debug="${compile.debug}" platform="${compile.platform}"
           noconfig="true" define="DEBUGMODE">
        <references refid="assemblyfileset-references" /> 
        <sources>
          <include name="${compilefiles}" />
          <include name="${AssemblyNameInfo.cs}" />
        </sources>
        <resources>
          <include name="${resourcefiles}" />
        </resources>
      </csc>
    </if>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="compile" />
    <call target="nant-subcall" cascade="false" />
  </if>
</target>

<target name="generateCsproject" depends="compile">
  <echo level="Debug">Calling antfile=${OP::get-current-buildfile()}</echo>
  <if test="${bool::parse(RunCsDepend)!=true}">
    <property name="ProjectGuid" value="{${OP::GUIDGen()}}" overwrite="false" />
    <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
      <call target="generateCsproject-internal" />
    </foreach>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="generateCsproject" />
    <call target="nant-subcall" cascade="false" />
  </if>
</target>

<target name="generateCsprojectNoCompile" depends="setreferences">
  <echo level="Debug">Calling antfile=${OP::get-current-buildfile()}</echo>
  <if test="${bool::parse(RunCsDepend)!=true}">
    <property name="ProjectGuid" value="{${OP::GUIDGen()}}" overwrite="false" />
    <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
      <call target="generateCsproject-internal" />
    </foreach>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="generateCsprojectNoCompile" />
    <call target="nant-subcall" cascade="false" />
  </if>
</target>

<target name="generateCsproject-internal" >
  <!-- Add cs and resx files -->
  <property name="templatedir" value="${path::combine(dir.incdir.template, devenv-name)}" />

  <property name="TemplateReferences" value="" />
  <property name="TemplateProjectReferences" value="" />
  <foreach item="File" property="reference-path">
    <in>
      <items refid="assemblyfileset-references" />
    </in>
    <do>  
      <!-- Extract reference name from the reference path-->
      <echo level="Debug">reference-path=${reference-path}</echo>
      <property name="reference-name" 
                value="${path::get-file-name-without-extension(reference-path)}" />
      <property name="relative-reference-path" value="${OP::GetRelativePath(reference-path, dir.projectfiles + '/' + devenv-name + '/')}"/>
      <property name="reference-project-file"
                value="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, reference-name+'.csproj'))}" />
      <property name="reference-project-file-name"
                value="${path::get-file-name(reference-project-file)}"/>
      <if test="${file::exists(reference-project-file)}">
        <!-- Reference to another project. Find GUID -->
        <xmlpeek
            file="${reference-project-file}"
            xpath="/*[local-name()='Project']/*[local-name()='PropertyGroup']/*[local-name()='ProjectGuid']"
            property="reference-project-guid"/>
        <loadfile file="${path::combine(templatedir, 'template.csproj.projectreference')}"
                  property="tempTemplateReferences" encoding="utf-8">  
          <filterchain>
            <expandproperties />
          </filterchain>
        </loadfile>
        <property name="TemplateProjectReferences" value="${TemplateProjectReferences}${tempTemplateReferences}" />
      </if>
      <if test="${not file::exists(reference-project-file)}">
        <property name="reference-with-hint" value="${not ((string::contains(reference-path,'Microsoft.NET\Framework') or string::contains(reference-path,'lib/mono/')) and file::exists(path::combine(templatedir, 'template.csproj.referencenohint')))}"/>
        <if test="${not reference-with-hint}">
          <loadfile file="${path::combine(templatedir, 'template.csproj.referencenohint')}"
                    property="tempTemplateReferences" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
        </if>
        <if test="${reference-with-hint}">
          <loadfile file="${path::combine(templatedir, 'template.csproj.reference')}"
                    property="tempTemplateReferences" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
        </if>
        <property name="TemplateReferences" value="${TemplateReferences}${tempTemplateReferences}" />
      </if>
    </do>
  </foreach>    

  <property name="TemplateResource" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="${resourcefiles}" />
      </items>
    </in>
    <do>
    <property name="relative-filename" value="${OP::GetRelativePath(filename, dir.projectfiles + '/' + devenv-name + '/')}"/>
    <property name="relative-filename-backslash" value="${string::replace(relative-filename, '/', '\\')}"/>
    <property name="DependentUpon" value="${path::change-extension(filename,'.cs')}" />
    <property name="relative-DependentUpon" value="${path::get-file-name(DependentUpon)}" />
    <property name="template" value="template.csproj.resource" />
    <if test="${file::exists(DependentUpon)}">
      <property name="template" value="template.csproj.resource.DependentUpon" />
    </if>
    <loadfile file="${path::combine(templatedir, template)}"
              property="tempTemplateResource" encoding="utf-8">  
      <filterchain>
        <expandproperties />
      </filterchain>
    </loadfile>
    <property name="TemplateResource" value="${TemplateResource}${tempTemplateResource}" />
    </do>
  </foreach>
  
  <property name="TemplateCompile" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="${compilefiles}" />
        <include name="${AssemblyNameInfo.cs}" />
      </items>
    </in>
    <do>
      <property name="justfilename" value="${path::get-file-name(filename)}" />
      <property name="relative-filename" value="${OP::GetRelativePath(filename, dir.projectfiles + '/' + devenv-name + '/')}"/>
      <property name="relative-filename-backslash" value="${string::replace(relative-filename, '/', '\\')}"/>
      <property name="template" value="template.csproj.compile" />
      <property name="DependentUpon" value=""/>
      <if test="${string::contains(filename,'.Designer.cs')}">
        <property name="DependentUpon" value="${string::replace(filename,'.Designer.cs','.cs')}" />
        <if test="${file::exists(DependentUpon)}">
          <property name="template" value="template.csproj.compile.DependentUpon" />
        </if>
      </if>
      <if test="${string::contains(filename,'.ManualCode.cs')}">
        <property name="DependentUpon" value="${string::replace(filename,'.ManualCode.cs','-generated.cs')}" />
        <if test="${file::exists(DependentUpon)}">
          <property name="template" value="template.csproj.compile.DependentUpon" />
        </if>
      </if>
      <property name="relative-DependentUpon" value="${path::get-file-name(DependentUpon)}"/>
      <loadfile file="${path::combine(templatedir, template)}"
                property="tempTemplateCompile" encoding="utf-8">  
        <filterchain>
          <expandproperties />
        </filterchain>
      </loadfile>
      <property name="TemplateCompile" value="${TemplateCompile}${tempTemplateCompile}" />  
    </do>
  </foreach>
  <!-- Add the finished project -->
  <copy file="${path::combine(templatedir, 'template.csproj')}"
        tofile="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, Namespace+'.csproj'))}" 
        overwrite="true">  
    <filterchain>
      <expandproperties />
    </filterchain>
  </copy>
  <!-- need to touch the dll file, so that later the fileset will pick this file up when calculating the references for other projects -->
  <if test="${not file::exists(path::combine(dir.bin, Namespace + '.dll'))}">
    <touch file="${dir.bin}/${Namespace}.dll"/>
  </if>
</target>

</project>