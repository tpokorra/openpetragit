<?xml version="1.0"?>
<project name="OpenPetra-csharp">

<include buildfile="OpenPetra.default.targets.xml"/>


<include buildfile="OpenPetra.references.xml"/>

<property name="RunCsDepend" value="true" overwrite="false"/>
<property name="OutputType" value="library" overwrite="false"/>
<property name="csc-ouput-ext" value="dll" if="${OutputType=='library'}" />
<property name="csc-ouput-ext" value="exe" unless="${OutputType=='library'}" />
<property name="AssemblyName" value="${Namespace}.${csc-ouput-ext}" />
<property name="namespace-temp-dir" value="${path::combine(tempdir,Namespace)}" />
<property name="AssemblyNameInfo.cs" value="${path::combine(namespace-temp-dir,'AssemblyInfo.cs')}" />
<property name="referencesFile" value="${path::combine(namespace-temp-dir,Namespace+'.generated.refs')}" />
<property name="resourcefiles" value="*.resx"  overwrite="false"/>
<property name="compilefiles" value="*.cs"  overwrite="false"/>
<property name="csdependfiles" value="**/*.cs"  overwrite="false"/>
<property name="excludecsfiles" value=".doc"  overwrite="false"/>



<target name="uncrustify" depends="indent" description="indent the code, so it adheres the formatting guidelines" />

<target name="indent" depends="" description="indent the code, so it adheres the formatting guidelines. Use nant -D:files=filename indent">
  <if test="${not property::exists('files')}">
  <!-- set all files as default -->
    <property name="files" value="" />
    <foreach item="File" property="filename" trim="Both">
      <in><items><include name="*.cs" /></items></in>
      <do><property name="files" value="${files} ${filename}" /></do>
    </foreach>
  </if>
  <property name="files" value="${string::trim(files)}" />
  <echo>files='${files}'</echo>
  <foreach item="String" in="${files}" delim=" " trim="Both" property="filename"><do>
    <if test="${0!=string::get-length(filename)}">
      <if test="${not OP::IsAutoGeneratedFile(filename)}">
        <exec program="${external.Uncrustify}" workingdir="${project::get-base-directory()}" resultproperty="rc"> 
          <arg value="-c" />
          <arg value="${dir.root}/csharp/ICT/PetraTools/CodeBeautifier/uncrustify-petra.cfg" />
          <arg value="--no-backup" />
          <arg value="${filename}" />
        </exec>
      </if>
    </if>
  </do></foreach>
</target>

<if test="${not target::exists('custclean')}">
  <include buildfile="OpenPetra.target-custclean.xml"/>
</if>

<target name="clean" depends="custclean">
  <if test="${not property::exists('called-nant-subcall')}">
    <if test="${file::exists(referencesFile)}">
      <include buildfile="${referencesFile}" />
      <property name="target" value="clean" />
      <property name="called-nant-subcall" value="true" />
      <call target="nant-subcall" cascade="false" />
    </if>
    <delete>
      <fileset>
        <include name="${dir.bin}/${AssemblyName}" asis="true" />
        <include name="${dir.bin}/${Namespace}.xml" asis="true" />
        <include name="${dir.bin}/${Namespace}.pdb" asis="true" />
        <include name="${path::combine(dir.namespace.map, Namespace + '.namespace-map')}" />        
      </fileset>
    </delete>
    <delete dir="${namespace-temp-dir}" />
    <if test="${bool::parse(RunCsDepend)}" >
      <!-- Only delete the files, if they were generated by this nant file -->
      <delete><fileset>
          <include name="**/*-generated.build" />
      </fileset></delete>
    </if>
  </if>
</target>

<if test="${not target::exists('custdepend')}">
  <include buildfile="OpenPetra.target-custdepend.xml"/>
</if>

<target name="depend" depends="custdepend">
  <if test="${true==bool::parse(RunCsDepend)}">
    <mkdir dir="${namespace-temp-dir}" />
    <mkdir dir="${dir.namespace.map}" />
    <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('CsDepend')}"/>
    <CsDepend ns-default="${Namespace}" ns-map-dir="${dir.namespace.map}" 
      basedir="${project::get-base-directory()}" uuidfile="${uuidFile}"
      referencesfile="${referencesFile}" buildincfile="${path::combine(dir.buildfiles, 'OpenPetra.csharp.xml')}">
      <sources>
        <include name="${csdependfiles}" />
        <exclude name="${excludecsfiles}" />
      </sources>    
    </CsDepend>
  </if>
  <call target="setreferences" />
</target>

<target name="setreferences" depends="">
  <if test="${true==bool::parse(RunCsDepend)}">
    <include buildfile="${referencesFile}" />
  </if>
  <assemblyfileset id="assemblyfileset-references">
    <lib>
      <include name="${dir.bin}"/>
    </lib>
    <patternset refid="references" />
    <patternset refid="csharpStdLibs" />
  </assemblyfileset>
</target>

<target name="compile" depends="depend">
  <!-- Create assembly info -->
  <if test="${bool::parse(RunCsDepend)!=true}">
    <mkdir dir="${namespace-temp-dir}" />
    <mkdir dir="${dir.bin}" />
    <asminfo output="${AssemblyNameInfo.cs}" language="CSharp">
      <imports>
        <import namespace="System.Reflection" />
        <import namespace="System.Runtime.CompilerServices" />
        <import namespace="System.Runtime.InteropServices" />
      </imports>
      <attributes>
        <attribute type="AssemblyTitle" value='"${Namespace}"' asis="true" />
        <attribute type="AssemblyDescription" value='""' asis="true" />
        <attribute type="AssemblyConfiguration" value='""' asis="true" />
        <attribute type="AssemblyCompany" value='"${info.assembly.company}"' asis="true" />
        <attribute type="AssemblyProduct" value='"${info.productname}"' asis="true" />
        <attribute type="AssemblyCopyright" value='"${info.assembly.copyright}"' asis="true" />
        <attribute type="AssemblyTrademark" value='""' asis="true" />
        <attribute type="AssemblyCulture" value='""' asis="true" />       
        <attribute type="ComVisible" value="false" asis="true" /> 
        <attribute type="AssemblyVersion" value='"${ReleaseID}"' asis="true" /> 
      </attributes>
    </asminfo>
    <!-- filealign="4096"  for csc not supported on mono -->
    <csc output="${dir.bin}/${AssemblyName}" 
         doc="${dir.bin}/${Namespace}.xml"
         target="${OutputType}" debug="${compile.debug}" 
         noconfig="true">
      <references refid="assemblyfileset-references" /> 
      <sources>
        <include name="${compilefiles}" />
        <include name="${AssemblyNameInfo.cs}" />
      </sources>
      <resources>
        <include name="${resourcefiles}" />
      </resources>
    </csc>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="compile" />
    <call target="nant-subcall" cascade="false" />
  </if>
  
</target>

<target name="generateCsproject" depends="compile">
  <echo level="Debug">Calling antfile=${OP::get-current-buildfile()}</echo>
  <if test="${bool::parse(RunCsDepend)!=true}">
    <property name="ProjectGuid" value="{${OP::GUIDGen()}}" overwrite="false" />
    <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
      <call target="generateCsproject-internal" />
    </foreach>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="generateCsproject" />
    <call target="nant-subcall" cascade="false" />
  </if>
</target>

<target name="generateCsprojectNoCompile" depends="setreferences">
  <echo level="Debug">Calling antfile=${OP::get-current-buildfile()}</echo>
  <if test="${bool::parse(RunCsDepend)!=true}">
    <property name="ProjectGuid" value="{${OP::GUIDGen()}}" overwrite="false" />
    <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
      <call target="generateCsproject-internal" />
    </foreach>
  </if>
  <if test="${bool::parse(RunCsDepend)==true}">
    <property name="target" value="generateCsprojectNoCompile" />
    <call target="nant-subcall" cascade="false" />
  </if>
</target>

<target name="generateCsproject-internal" >
  <!-- Add cs and resx files -->
  <property name="templatedir" value="${path::combine(dir.incdir.template, devenv-name)}" />

  <property name="TemplateReferences" value="" />
  <property name="TemplateProjectReferences" value="" />
  <foreach item="File" property="reference-path">
    <in>
      <items refid="assemblyfileset-references" />
    </in>
    <do>  
      <!-- Extract reference name from the reference path-->
      <echo level="Debug">reference-path=${reference-path}</echo>
      <property name="reference-name" 
                value="${path::get-file-name-without-extension(reference-path)}" />
      <property name="reference-project-file"
                value="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, reference-name+'.csproj'))}" />           
      <if test="${file::exists(reference-project-file)}">
        <!-- Reference to another project. Find GUID -->
        <xmlpeek
            file="${reference-project-file}"
            xpath="/*[local-name()='Project']/*[local-name()='PropertyGroup']/*[local-name()='ProjectGuid']"
            property="reference-project-guid"/>
        <loadfile file="${path::combine(templatedir, 'template.csproj.projectreference')}"
                  property="tempTemplateReferences" encoding="utf-8">  
          <filterchain>
            <expandproperties />
          </filterchain>
        </loadfile>
        <property name="TemplateProjectReferences" value="${TemplateProjectReferences}${tempTemplateReferences}" />
      </if>
      <if test="${not file::exists(reference-project-file)}">
        <loadfile file="${path::combine(templatedir, 'template.csproj.reference')}"
                  property="tempTemplateReferences" encoding="utf-8">  
          <filterchain>
            <expandproperties />
          </filterchain>
        </loadfile>
        <property name="TemplateReferences" value="${TemplateReferences}${tempTemplateReferences}" />
      </if>
    </do>
  </foreach>    

  <property name="TemplateResource" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="${resourcefiles}" />
      </items>
    </in>
    <do>
    <property name="DependentUpon" value="${path::change-extension(filename,'.cs')}" />
    <property name="template" value="template.csproj.resource" />
    <if test="${file::exists(DependentUpon)}">
      <property name="template" value="template.csproj.resource.DependentUpon" />
    </if>
    <loadfile file="${path::combine(templatedir, template)}"
              property="tempTemplateResource" encoding="utf-8">  
      <filterchain>
        <expandproperties />
      </filterchain>
    </loadfile>
    <property name="TemplateResource" value="${TemplateResource}${tempTemplateResource}" />
    </do>
  </foreach>
  
  <property name="TemplateCompile" value="" />
  <foreach item="File" property="filename">
    <in>
      <items>
        <include name="${compilefiles}" />
        <include name="${AssemblyNameInfo.cs}" />
      </items>
    </in>
    <do>
      <loadfile file="${path::combine(templatedir, 'template.csproj.compile')}"
                property="tempTemplateCompile" encoding="utf-8">  
        <filterchain>
          <expandproperties />
        </filterchain>
      </loadfile>
      <property name="TemplateCompile" value="${TemplateCompile}${tempTemplateCompile}" />  
    </do>
  </foreach>
  <!-- Add the finshed project -->
  <copy file="${path::combine(templatedir, 'template.csproj')}"
        tofile="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, Namespace+'.csproj'))}" 
        overwrite="true">  
    <filterchain>
      <expandproperties />
    </filterchain>
  </copy>
</target>

</project>