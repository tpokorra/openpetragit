<?xml version="1.0"?>
<project name="OpenPetra" default="help">

<echo>operating system=${operating-system::to-string(environment::get-operating-system())}</echo>
<echo>platform=${platform::get-name()}</echo>


<include buildfile="inc/nant/OpenPetra.common.xml"/>

<!-- nant -projecthelp does not show imported targets-->
<target name="help" depends="" description="Displays the available targets and parameters.">
    <echo>
list of available commands:
  clean: cleans everything
  compile: compiles OpenPetra including testing
  generateSolution: compiles OpenPetra and generates the project and solution files
  generateSolutionNoCompile: generates the project and solution files. compile should already be executed
  minimalGenerateSolution: generates the project and solution files. compiles what it needs, but does not compile all code
  quickCompile: will just compile the solution file, with msbuild (Windows) or xbuild (Linux)
      nant quickCompile                    will compile the OpenPetra.sln
      nant quickCompile -D:solution=Tools  will compile the OpenPetra.Tools.sln
                                           other solutions are: Client, Server, Testing
  quickClean: cleans all generated files and the delivery directory
  startPetraServer: run a local Petra Server
  stopPetraServer: stop the local Petra Server
  startPetraClient: run the Petra Client
  deleteBakFiles: delete all backup files
  buildRelease: Build the release for the target platform we are building on
  initConfigFiles: write and overwrite the config files for client, server and testing, and the version.txt

compat:
  createSQLStatements: generates the sql create table statements etc from the petra.xml
  dbdoc: generates database design documentation using sql2diagram
  recreateDatabase: needed after changes in table structure in petra.xml
  resetDatabase: just resets the data, resets the permissions
  patchDatabase: update the database to the latest development version
  dumpDatabase: dump the database to a db specific format.
        nant dumpDatabase -D:OutputDB.file=test.sql
  loadDatabase: load the database from a db specific dump
        nant loadDatabase -D:LoadDB.file=test.sql
  generateORM: generates Object Relational Mapping routines from petra.xml
    sub items: generateORMCachedTables, generateORMData, generateORMAccess
  generateGlue: generates the interfaces and instantiators, which is the glue between client and server
  generateWinforms: generates all yaml files in csharp\ICT\Petra\Client
  generateWinform: generate a single yaml file, and optionally compile and start the client
       nant generateWinform startPetraClient -D:file=MFinance/Gui/GL/GLBatch.yaml
       nant generateWinform -D:file=MFinance/Gui/GL/GLBatch.yaml -D:donotcompile=true
  cleanPetra: prepare for a clean build
  compilePetra: build all Petra C# code
  translationCompilePOFile: create the dlls required to be delivered with a new release
  translation: extracts string in winforms, creates and updates the .po files, and compiles the dll files for delivery

list of commands, which works in the specific csharp directories:
  indent: beautify the code according to coding style guide
  uncrustify: calls indent


not supported
  loc, ploc: count the lines of code, to be used for COCOMO etc
  generateWebforms: generates the User Interface using the Ext.js AJAX framework
  generateWebform: generate a single Webform. requires parameter: -D:file=SampleApplicationForm
  startWebServer: start a webservice with Mono XSP and Postgresl (does not work with sqlite at the moment)
  buildRemoteInstallers -D:ReleaseID=0.0.2.0 -D:OrgName=&quot;Your Organisation&quot; -D:PublisherUrl=www.ProviderWebsite.com -D:HostedServer=app.Provider.com -D:HostedPort=9000
  createPatch: requires these parameters: -D:OldVersion=0.0.8-1 -D:NewVersion=0.0.10-0
  packTestReportingRelease: quick snapshot of all debug executables and dlls and config files for quick test on another machine
  
useful parameters
  -logfile:test.log
</echo>
</target>

<target name="apiDoc" description="Generates API documentation. nant depend should have been run" >
  <exec program="${external.doxygen}">
    <arg value="&quot;${external.doxygen.configfile}&quot;" />
  </exec>  
</target>

<target name="translationCompilePOFile" description="create the dlls with the i18n messages" >
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="i18n/i18n.build" />
</target>

<target name="custclean" description="Cleans the solution and project files">
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <delete>
      <fileset basedir="${path::combine(dir.projectfiles,devenv-name)}">
        <include name="OpenPetra*.sln" />
        <include name="*.csproj" />
      </fileset>
    </delete>
  </foreach>
  <delete> 
    <fileset basedir="${dir.delivery}" >  
      <include name="OpenPetraSetup-*.exe" />
    </fileset>
  </delete>
  <property name="target" value="clean" />
  <call target="translationCompilePOFile" />
</target>

<target name="quickClean" description="cleans all generated files and the delivery directory">
  <!-- Do not remove dir.delivery, because this would change all UUIDs from the project files -->
  <delete dir="${dir.bin}"/>
  <delete dir="${dir.namespace.map}"/>
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <delete dir="${path::combine(dir.projectfiles,devenv-name)}" />
  </foreach>
  <delete>
    <fileset basedir="${dir.root}">
      <include name="**/*-generated.build" />
      <include name="**/*-generated.cs" />
      <include name="**/*-generated.resx" />
      <include name="**/*-generated.Designer.cs" />
      <include name="**/*.generated.refs" />
      <include name="tmp/**/AssemblyInfo.cs" />
    </fileset>
  </delete>
</target>

<target name="nanttasks" depends="" description="goes into the directory inc/nanttasks">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="inc/nanttasks/nanttasks.build" />
</target>

<target name="csharp" depends="nanttasks" description="goes into the directory csharp">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="csharp/csharp.build" />
</target>

<target name="internal-subdirs" description="Goes into all necessary subdirectories" 
        depends="csharp,nanttasks" />

<target name="generateSolutionNoCompile" description="generates the project and solution files. Target compile should already be executed">
  <call target="generateCsprojectNoCompile" />
  <call target="generate-solution-all-internal" />
</target>

<target name="minimalGenerateSolution" description="compile minimal code for generating source code and the project and solution files">
  <!-- compile minimal needed tools -->
  <call target="nanttasks"/>
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ThirdParty/ThirdParty.build" />
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ICT/Common/ICT.Common.build" />
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ICT/PetraTools/ICT.PetraTools.build" />
  <!-- Find all dependencies -->
  <mkdir dir="${dir.bin}" />
  <!-- write this information to a file, since the properties are not passed through to the sub directories -->
  <echo file="${dir.bin}/dont_compile.txt">true</echo>
  <nant inheritall="false" target="depend" 
        buildfile="csharp/csharp.build" />
  <!-- Generate the project/solution files -->
  <call target="generateSolutionNoCompile" />
  <delete file="${dir.bin}/dont_compile.txt"/>
</target>

<target name="generateSolution" description="compiles OpenPetra and generates the project and solution files">
  <delete file="${dir.bin}/dont_compile.txt"/>
  <call target="compile" />
  <call target="generateSolutionNoCompile" />
</target>

<!-- Generate solution targets -->
<target name="generate-solution-all-internal" >
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <!-- OpenPetra.sln -->
    <property name="includepaths" value="Common,Petra,PetraTools,Testing"/>
    <property name="solution-name" value="OpenPetra.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Server.sln -->
    <property name="includepaths" value="Common,Petra/Shared,Petra/Server,Petra/ServerPlugins,Petra/PetraServerConsole"/>
    <property name="solution-name" value="OpenPetra.Server.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Client.sln -->
    <property name="includepaths" value="Common,Petra/Shared,Petra/Client,Petra/ClientPlugins,Petra/PetraClient"/>
    <property name="solution-name" value="OpenPetra.Client.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Tools.sln -->
    <property name="includepaths" value="Common,PetraTools"/>
    <property name="solution-name" value="OpenPetra.Tools.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Testing.sln -->
    <property name="includepaths" value="Common,PetraTools,Petra/Shared,Petra/Client,Petra/ClientPlugins,Petra/Server,Petra/ServerPlugins,Testing"/>
    <property name="solution-name" value="OpenPetra.Testing.sln"/>
    <call target="generate-solution-internal" />
  </foreach>
</target>


<target name="generate-solution-internal" >
  <property name="templatedir" value="${path::combine(dir.incdir.template, devenv-name)}" />
  <property name="TemplateProject" value="" />
  <property name="TemplateConfiguration" value="" />
  <property name="SolutionGuid" value="{${OP::GUIDGen()}}" />
  <!-- collect all project files -->
  <property name="projectfiles" value="^"/>
  <foreach item="File" property="ProjectFile">
    <in>
      <items basedir="${path::combine(dir.projectfiles, devenv-name)}">
        <include name="*.csproj"/>
      </items>
    </in>
    <do>
      <property name="projectfiles" value="${projectfiles},${ProjectFile}"/>
    </do>
  </foreach>
  <property name="projectfiles" value="${string::replace(projectfiles,'^,','')}"/>
  <foreach item="String" property="ProjectFile" delim="," in="${projectfiles}">
    <do>
      <!-- do we need to remove the xmlns="http://schemas.microsoft.com/developer/msbuild/2003" from the project file so that xmlpeek works? -->
      <property name="temp" value="${script::ReplaceInFile(ProjectFile, 'xmlns', 'xmlnsDeactivated')}"/>  
      <xmlpeek file="${ProjectFile}"
              xpath="/Project/PropertyGroup/ProjectGuid"
              property="ProjectGuid"/>
      <xmlpeek file="${ProjectFile}"
              xpath="//Compile[1]/@Include"
              property="FirstCSFile"/>
      <property name="temp" value="${script::ReplaceInFile(ProjectFile, 'xmlnsDeactivated', 'xmlns')}"/>
      
      <property name="FirstCSFile" value="${OP::MakeAbsolute(FirstCSFile, dir.projectfiles + '/' + devenv-name + '/')}"/>
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,dir.root,'')}"/>
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,'\','/')}"/>
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,'/csharp/ICT/','')}"/>
      <foreach item="String" property="includePath" delim="," in="${includepaths}" >
        <if test="${string::starts-with(FirstCSFile,includePath+'/')}">
          <property name="ProjectName" value="${path::get-file-name-without-extension(ProjectFile)}" />
          <loadfile file="${path::combine(templatedir, 'template.sln.project')}"
                    property="tempTemplateProject" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
          <property name="TemplateProject" value="${TemplateProject}${tempTemplateProject}" />
          <loadfile file="${path::combine(templatedir, 'template.sln.configuration')}"
                    property="tempTemplateConfiguration" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
          <property name="TemplateConfiguration" value="${TemplateConfiguration}${tempTemplateConfiguration}" />
        </if>
      </foreach>
    </do>
  </foreach>
  <copy file="${path::combine(templatedir, 'template.sln')}"
        tofile="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, solution-name))}" 
        overwrite="true">  
    <filterchain>
      <expandproperties />
    </filterchain>
  </copy>

</target>

<!-- Include default implementation -->
<include buildfile="inc/nant/OpenPetra.subdirs.xml"/> 

<!-- Compat targets -->
<include buildfile="inc/nant/OpenPetra.tobe.migrated.xml"/>

<!-- tasks for building releases -->
<include buildfile="setup/setup.build"/>

<target name="quickCompile">
  <!-- this is very different from the compile target. quickCompile does not generate any code. 
       quickCompile uses the solution and csproj files and msbuild.
       quickCompile is intended as an alternative to compile in SharpDevelop directly.
  -->
  <property name="solution" value="OpenPetra" overwrite="false"/>
  <property name="solution.file" value="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, 'OpenPetra.'+solution+'.sln'))}"/>
  <property name="solution.file" value="${string::replace(solution.file, 'OpenPetra.OpenPetra.sln', 'OpenPetra.sln')}"/>
  <if test="${not platform::is-windows()}" >
    <if test="${property::exists('xbuild')}">
      <exec program="${xbuild}" commandline="${solution.file}">
         <environment>
           <variable name="MONO_PATH" value="${NAntBin.dir}"/> <!-- variable does not exist yet; otherwise: value="${NAntBin.dir}:${environment::get-variable('MONO_PATH')}" -->
         </environment>
      </exec>
    </if>
  </if>
  <if test="${platform::is-windows()}" >
    <if test="${file::exists(msbuildtask.file)}">
      <msbuild project="${solution.file}" verbosity="Minimal">
        <property name="Configuration" value="${Configuration}"/>
      </msbuild>
    </if>
    <if test="${not file::exists(msbuildtask.file)}">
      <fail message="you need the NAnt.Contrib.Tasks.dll for msbuild" />
    </if>
  </if>
</target>

<target name="generateORM" depends="generateORMCachedTables,generateORMData,generateORMAccess">
  <echo message="please compile the code after the files have been regenerated"/>
</target>

<target name="generateORMData">
  <!-- generate the files for Ict.Petra.Shared.lib.data, ie. the tables and datasets -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Shared/Ict.Petra.Shared.build')}" verbose="${verbose}"/>
</target>

<target name="generateORMAccess">
  <!-- generate the files for Ict.Petra.Server.lib.data, ie. the access files for reading from and writing to the database -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Server/Ict.Petra.Server.build')}" verbose="${verbose}"/>
</target>

<target name="generateWinforms">
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Client/Ict.Petra.Client.build')}" verbose="${verbose}"/>
</target>

<target name="generateWinform">
  <nant inheritall="true" target="generateWinform" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Client/Ict.Petra.Client.build')}" verbose="${verbose}"/>
</target>

</project>

