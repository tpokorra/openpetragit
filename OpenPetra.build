<?xml version="1.0"?>
<project name="OpenPetra" default="help">

<echo>operating system=${operating-system::to-string(environment::get-operating-system())}</echo>
<echo>platform=${platform::get-name()}</echo>


<include buildfile="inc/nant/OpenPetra.common.xml"/>

<!-- nant -projecthelp does not show imported targets-->
<target name="help" depends="" description="Displays the available targets and parameters.">
    <echo>
list of available commands:
  clean: cleans everything
  compile: compiles OpenPetra including testing
  generateSolution: compiles OpenPetra and generates the project and solution files
  generateSolutionNoCompile: generates the project and solution files. compile should already be executed
  minimalGenerateSolution: generates the project and solution files. compiles what it needs, but does not compile all code
  quickCompile: will just compile the solution file, with msbuild (Windows) or xbuild (Linux)
      nant quickCompile                    will compile the OpenPetra.sln
      nant quickCompile -D:solution=Tools  will compile the OpenPetra.Tools.sln
                                           other solutions are: Client, Server, Testing
  quickClean: cleans all generated files and the delivery directory
  startPetraServer: run a local Petra Server
  stopPetraServer: stop the local Petra Server
  startPetraClient: run the Petra Client
  deleteBakFiles: delete all backup files
  buildRelease: Build the release for the target platform we are building on
  initConfigFiles: write and overwrite the config files for client, server and testing, and the version.txt

compat:
  createSQLStatements: generates the sql create table statements etc from the petra.xml
  dbdoc: generates database design documentation using sql2diagram
  recreateDatabase: needed after changes in table structure in petra.xml
  resetDatabase: just resets the data, resets the permissions
  patchDatabase: update the database to the latest development version
  generateORM: generates Object Relational Mapping routines from petra.xml
     sub items: generateORMCachedTables, generateORMData, generateORMAccess
  generateGlue: generates the interfaces and instantiators, which is the glue between client and server
  cleanPetra: prepare for a clean build
  compilePetra: build all Petra C# code
  translationCompilePOFile: create the dlls required to be delivered with a new release
  translation: extracts string in winforms, creates and updates the .po files, and compiles the .mo files for delivery

list of commands, which works in the specific csharp directories:
  indent: beautify the code according to coding style guide
  uncrustify: calls indent


not supported
  loc, ploc: count the lines of code, to be used for COCOMO etc
  generateWebforms: generates the User Interface using the Ext.js AJAX framework
  generateWebform: generate a single Webform. requires parameter: -D:file=SampleApplicationForm
  startWebServer: start a webservice with Mono XSP and Postgresl (does not work with sqlite at the moment)
  setupRemote -D:ReleaseID=0.0.2.0 -D:OrgName=&quot;Your Organisation&quot; -D:PublisherUrl=www.ProviderWebsite.com -D:ServerHost=app.Provider.com -D:ServerPort=9000
  createPatch: requires these parameters: -D:OldVersion=0.0.8-1 -D:NewVersion=0.0.10-0
  packTestReportingRelease: quick snapshot of all debug executables and dlls and config files for quick test on another machine
  
useful parameters
  -logfile:test.log
</echo>
</target>

<target name="translationCompilePOFile" description="create the dlls with the i18n messages" >
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="i18n/i18n.build" />
</target>

<target name="custclean" description="Cleans the solution and project files">
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <delete>
      <fileset basedir="${path::combine(dir.projectfiles,devenv-name)}">
        <include name="OpenPetra.sln" />
        <include name="*.csproj" />
      </fileset>
    </delete>
  </foreach>
  <delete> 
    <fileset basedir="${dir.delivery}" >  
      <include name="OpenPetraSetup-*.exe" />
    </fileset>
  </delete>
  <property name="target" value="clean" />
  <call target="translationCompilePOFile" />    
</target>

<target name="quickClean" description="cleans all generated files and the delivery directory">
  <delete dir="${dir.delivery}"/>
  <mkdir dir="${dir.delivery}"/>
  <delete>
    <fileset basedir="${dir.root}">
      <include name="**/*-generated.build" />
      <include name="**/*-generated.cs" />
      <include name="**/*-generated.resx" />
      <include name="**/*-generated.Designer.cs" />
      <include name="**/*.generated.refs" />
      <include name="tmp/**/AssemblyInfo.cs" />
    </fileset>
  </delete>
</target>

<target name="nanttasks" depends="" description="goes into the directory inc/nanttasks">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="inc/nanttasks/nanttasks.build" />
</target>

<target name="csharp" depends="nanttasks" description="goes into the directory csharp">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="csharp/csharp.build" />
</target>

<target name="internal-subdirs" description="Goes into all necessary subdirectories" 
        depends="csharp,nanttasks" />

<target name="generateSolutionNoCompile" description="generates the project and solution files. Target compile should already be executed">
  <call target="generateCsprojectNoCompile" />
  <call target="generate-solution-all-internal" />
</target>

<target name="minimalGenerateSolution" description="compile minimal code for generating source code and the project and solution files">
  <!-- compile minimal needed tools -->
  <call target="nanttasks"/>
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ThirdParty/ThirdParty.build" />
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ICT/Common/ICT.Common.build" />
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ICT/PetraTools/ICT.PetraTools.build" />
  <!-- Find all dependencies -->
  <nant inheritall="false" target="depend" 
        buildfile="csharp/csharp.build" />
  <!-- Generate the project/solution files -->
  <call target="generateSolutionNoCompile" />
</target>

<target name="generateSolution" depends="compile" description="compiles OpenPetra and generates the project and solution files">
  <call target="generateSolutionNoCompile" />
</target>

<!-- Generate solution targets -->
<target name="generate-solution-all-internal" >
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <!-- OpenPetra.sln -->
    <property name="includepaths" value="Common,Petra,PetraTools,Testing"/>
    <property name="solution-name" value="OpenPetra.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Server.sln -->
    <property name="includepaths" value="Common,Petra/Shared,Petra/Server,Petra/ServerPlugins,Petra/PetraServerConsole"/>
    <property name="solution-name" value="OpenPetra.Server.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Client.sln -->
    <property name="includepaths" value="Common,Petra/Shared,Petra/Client,Petra/ClientPlugins,Petra/PetraClient"/>
    <property name="solution-name" value="OpenPetra.Client.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Tools.sln -->
    <property name="includepaths" value="Common,PetraTools"/>
    <property name="solution-name" value="OpenPetra.Tools.sln"/>
    <call target="generate-solution-internal" />
    <!-- OpenPetra.Testing.sln -->
    <property name="includepaths" value="Common,PetraTools,Petra/Shared,Petra/Client,Petra/ClientPlugins,Petra/Server,Petra/ServerPlugins,Testing"/>
    <property name="solution-name" value="OpenPetra.Testing.sln"/>
    <call target="generate-solution-internal" />
  </foreach>
</target>


<target name="generate-solution-internal" >
  <property name="templatedir" value="${path::combine(dir.incdir.template, devenv-name)}" />
  <property name="TemplateProject" value="" />
  <property name="TemplateConfiguration" value="" />
  <property name="SolutionGuid" value="{${OP::GUIDGen()}}" />
  <!-- collect all project files -->
  <property name="projectfiles" value="^"/>
  <foreach item="File" property="ProjectFile">
    <in>
      <items basedir="${path::combine(dir.projectfiles, devenv-name)}">
        <include name="*.csproj"/>
      </items>
    </in>
    <do>
      <property name="projectfiles" value="${projectfiles},${ProjectFile}"/>
    </do>
  </foreach>
  <property name="projectfiles" value="${string::replace(projectfiles,'^,','')}"/>
  <foreach item="String" property="ProjectFile" delim="," in="${projectfiles}">
    <do>
      <!-- do we need to remove the xmlns="http://schemas.microsoft.com/developer/msbuild/2003" from the project file so that xmlpeek works? -->
      <property name="temp" value="${script::ReplaceInFile(ProjectFile, 'xmlns', 'xmlnsDeactivated')}"/>  
      <xmlpeek file="${ProjectFile}"
              xpath="/Project/PropertyGroup/ProjectGuid"
              property="ProjectGuid"/>
      <xmlpeek file="${ProjectFile}"
              xpath="//Compile[1]/@Include"
              property="FirstCSFile"/>
      <property name="temp" value="${script::ReplaceInFile(ProjectFile, 'xmlnsDeactivated', 'xmlns')}"/>
      
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,dir.root,'')}"/>
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,'\','/')}"/>
      <property name="FirstCSFile" value="${string::replace(FirstCSFile,'/csharp/ICT/','')}"/>
      <foreach item="String" property="includePath" delim="," in="${includepaths}" >
        <if test="${string::starts-with(FirstCSFile,includePath+'/')}">
          <property name="ProjectName" value="${path::get-file-name-without-extension(ProjectFile)}" />
          <loadfile file="${path::combine(templatedir, 'template.sln.project')}"
                    property="tempTemplateProject" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
          <property name="TemplateProject" value="${TemplateProject}${tempTemplateProject}" />
          <loadfile file="${path::combine(templatedir, 'template.sln.configuration')}"
                    property="tempTemplateConfiguration" encoding="utf-8">  
            <filterchain>
              <expandproperties />
            </filterchain>
          </loadfile>
          <property name="TemplateConfiguration" value="${TemplateConfiguration}${tempTemplateConfiguration}" />
        </if>
      </foreach>
    </do>
  </foreach>
  <copy file="${path::combine(templatedir, 'template.sln')}"
        tofile="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, solution-name))}" 
        overwrite="true">  
    <filterchain>
      <expandproperties />
    </filterchain>
  </copy>

</target>

<!-- Include default implementation -->
<include buildfile="inc/nant/OpenPetra.subdirs.xml"/> 

<!-- Compat targets -->
<include buildfile="inc/nant/OpenPetra.tobe.migrated.xml"/>

<!-- BEGIN buildRelease -->
<target name="buildRelease" depends="buildReleaseLinux,buildReleaseWindows" 
        description="Build the release for the target platform we are building on" />

<property name="BuildClientArchive" value="false" overwrite="false" />
<property name="SkipDatabases" value="false" overwrite="false" />
<property name="PetraRelease" value="0300" overwrite="false" />

<!-- Windows -->
<target name="buildReleaseWindows" if="${platform::is-windows()}">
  <call target="compile" unless="${target::has-executed('compile')}" />
  <call target="createSQLiteDB" unless="${target::has-executed('createSQLiteDB')}"/>
  <call target="translationCompilePOFile" unless="${target::has-executed('translationCompilePOFile')}"/>
  <call target="setupStandalone" unless="${target::has-executed('setupStandalone')}"/>
</target> 

<script language="C#">
  <references>
    <include name="System.dll" />
  </references>
  <code><![CDATA[ 
[Function("CalculateStandaloneDBUpdateFileName")]
public static string CalculateStandaloneDBUpdateFileName(string ReleaseID)
{
    string[] numbers = ReleaseID.Split(new char[]{'.', '-'});
    
    // need to manually code the medium version increases
    if (numbers[1] == "1" && numbers[2] == "0")
    {
        return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                        0, 0, 15,
                        numbers[0], numbers[1], numbers[2]);
    }

    if (numbers[1] == "2" && numbers[2] == "0")
    {
        return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                        0, 1, 0,
                        numbers[0], numbers[1], numbers[2]);
    }

    // this is for smaller patches
    return String.Format("Patch_{0}.{1}.{2}_{3}.{4}.{5}.sql",
                        numbers[0], numbers[1], Convert.ToInt16(numbers[2]) - 1,
                        numbers[0], numbers[1], numbers[2]);
}
]]>
    </code>
</script> 
  
<target name="setupStandalone">
    <echo file="${dir.root}/setup/petra${PetraRelease}/standalone/version.txt">${ReleaseID}</echo>
    <property name="DBUpdate.file" value="${dir.root}/db/patches/${script::CalculateStandaloneDBUpdateFileName(ReleaseID)}"/>
    <if test="${not file::exists(DBUpdate.file)}">
        <echo message="${DBUpdate.file}"/>
        <fail message="We are missing the db upgrade file for sqlite standalone databases." />
    </if>
    <property name="SetupOriginal.File" value="${dir.root}/setup/petra${PetraRelease}/standalone/standalone.iss"/>
    <call target="setupTemplate"/>
</target>

<target name="setupTemplate">
    <property name="Current.File" value="${SetupOriginal.File}.local"/>

    <copy file="${SetupOriginal.File}" tofile="${Current.File}" overwrite="true"/>

    <property name="toReplace" value="{#UINAVIGATION}"/>
    <property name="UINavigation.file" value="UINavigation.yml.my"/>
    <if test="${file::exists(UINavigation.file)}">
        <echo message='${script::ReplaceInFile(Current.File, toReplace, UINavigation.file)}'/>
    </if>
    <if test="${not file::exists(UINavigation.file)}">
        <property name="UINavigation.file" value="UINavigation.yml"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, UINavigation.file)}'/>
    </if>

    <property name="toReplace" value="{#REMOTECONFIG}"/>
    <property name="Config.file" value="PetraClientRemote.config.my"/>
    <if test="${file::exists(Config.file)}">
        <echo message='${script::ReplaceInFile(Current.File, toReplace, Config.file)}'/>
    </if>
    <if test="${not file::exists(Config.file)}">
        <property name="Config.file" value="PetraClientRemote.config"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, Config.file)}'/>
    </if>

    <property name="toReplace" value="{#RELEASEVERSION}"/>
    <echo message='${script::ReplaceInFile(Current.File, toReplace, ReleaseVersion)}'/>
    <property name="toReplace" value="{#RELEASEID}"/>
    <echo message='${script::ReplaceInFile(Current.File, toReplace, ReleaseID)}'/>
    <property name="toReplace" value="{#PATCHVERSION}"/>
    <echo message='${script::ReplaceInFile(Current.File, toReplace, ReleaseID)}'/>
    <property name="toReplace" value="{#DELIVERY.DIR}"/>
    <echo message='${script::ReplaceInFile(Current.File, toReplace, dir.delivery)}'/>
    
    <!-- for remote installer -->
    <if test="${property::exists('OrgName')}">
        <property name="toReplace" value="{#ORGNAME}"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, OrgName)}'/>
        <property name="toReplace" value="{#PUBLISHERURL}"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, PublisherUrl)}'/>
        <property name="toReplace" value="{#SERVERHOST}"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, ServerHost)}'/>
        <property name="toReplace" value="{#SERVERPORT}"/>
        <echo message='${script::ReplaceInFile(Current.File, toReplace, ServerPort)}'/>
    </if>
    <exec program="${Innosetup.ISCC}" commandline=" &quot;${Current.File}&quot;"
          workingdir="${path::get-directory-name(Current.File)}"/>
</target>

<!-- Linux -->
<target name="buildReleaseLinux" if="${platform::is-unix()}">
  <call target="refreshSudo" unless="${target::has-executed('refreshSudo')}" />
  <call target="compile" unless="${target::has-executed('compile')}" />
  <call target="createPostgreSQLDB" unless="${target::has-executed('createPostgreSQLDB')}"/>
  <call target="createMySQLDB" unless="${target::has-executed('createMySQLDB')}"/>
  <call target="createSQLiteDB" unless="${target::has-executed('createSQLiteDB')}"/>
  <call target="translationCompilePOFile" unless="${target::has-executed('translationCompilePOFile')}"/>
  <call target="setupLinuxServer" unless="${target::has-executed('setupLinuxServer')}"/>
</target>

<target name="setupLinuxServer">
<!-- for the moment, just create a tar.gz file, with sub directories manuals30 containing the release notes, 
     bin30 with just the server binaries, db30 with the demo sqlite database, demo30 with some sample files,
     reports30, sql30 with the sql scripts, etc30 with the 2 config files; start and maintain script in the root
     LICENSE file in the root, INSTALL file with instructions, required packages, firewall etc? -->
  <property name="setupDir" value="${dir.bin}/tmp/openpetraorg-${ReleaseID}"/>
  <delete dir="${setupDir}"/>
  <mkdir dir="${setupDir}"/>

  <if test="${SkipDatabases!='true'}">
    <mkdir dir="${setupDir}/db30"/>
    <mkdir dir="${setupDir}/demo30"/>
    <mkdir dir="${setupDir}/log30"/>
    <mkdir dir="${setupDir}/etc30"/>
    <mkdir dir="${setupDir}/reports30"/>
    <mkdir dir="${setupDir}/patches30"/>  
    <if test="${not BuildClientArchive}">
      <copy todir="${setupDir}/etc30">
          <fileset basedir="${dir.root}/setup/petra${PetraRelease}/linuxserver/">
              <include name="*.config" />
          </fileset>
      </copy>
    </if>
    <copy todir="${setupDir}/demo30">
        <fileset basedir="${dir.bin}/demodata/">
            <include name="**/*.*" />
        </fileset>
    </copy>
  </if>
  <mkdir dir="${setupDir}/manuals30"/>
  <mkdir dir="${setupDir}/sql30"/>
  <mkdir dir="${setupDir}/resources30"/>
  <mkdir dir="${setupDir}/bin30"/>
  <copy file="${dir.root}/db/patches/version.txt" tofile="${setupDir}/bin30/version.txt" />
  <copy todir="${setupDir}/bin30">
    <fileset basedir="${dir.bin}">
      <include name="*.dll" />
      <include name="*.exe" />
      <exclude name="Tests*" />
      <include name="*/*.dll" /> <!-- i18n DLLs-->
    </fileset>
  </copy>
  <copy file="${dir.bin}/csharp/ICT/Petra/Definitions/UINavigation.yml"
              tofile="${setupDir}/bin30/UINavigation.yml"/>
  <copy todir="${setupDir}/resources30">
    <fileset basedir="${dir.bin}/resources">
        <include name="*.ico" />
        <include name="*.png" />
    </fileset>
  </copy>       
  <if test="${BuildClientArchive}">
    <copy todir="${setupDir}/etc30" 
          file="${dir.bin}/setup/petra${PetraRelease}/remoteclientWin/PetraClientRemote.config" />
  </if>
  <copy todir="${setupDir}/manuals30">
    <fileset basedir="${dir.bin}/setup/petra${PetraRelease}/releasenotes/">
      <include name="*.html" />
    </fileset>
  </copy>
  <copy todir="${setupDir}/reports30">
    <fileset basedir="${dir.bin}/XmlReports/">
      <include name="*.dtd" />
      <include name="**/*.xml" />
    </fileset>
  </copy>
  <copy file="${dir.bin}/LICENSE" tofile="${setupDir}/LICENSE"/>
  <if test="${not BuildClientArchive}">
    <copy todir="${setupDir}/sql30">
      <fileset basedir="${dir.bin}/csharp/ICT/Petra/Server/sql/">
          <include name="*.sql" />
          <include name="*.yml" />
      </fileset>
    </copy>
    <if test="${SkipDatabases!='true'}">
      <copy file="${dir.bin}/setup/petra${PetraRelease}/demo.db"
                  tofile="${setupDir}/db30/demo.db"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/createtables-PostgreSQL.sql"
                  tofile="${setupDir}/db30/createtables-PostgreSQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/createconstraints-PostgreSQL.sql"
                  tofile="${setupDir}/db30/createconstraints-PostgreSQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/demodata-PostgreSQL.sql"
                  tofile="${setupDir}/db30/demodata-PostgreSQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/createtables-MySQL.sql"
                  tofile="${setupDir}/db30/createtables-MySQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/createconstraints-MySQL.sql"
                  tofile="${setupDir}/db30/createconstraints-MySQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/demodata-MySQL.sql"
                  tofile="${setupDir}/db30/demodata-MySQL.sql"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/linuxserver/INSTALL"
                  tofile="${setupDir}/INSTALL"/>
      <if test="${SkipCompileClient!='true'}">
        <copy file="${dir.bin}/setup/petra${PetraRelease}/linuxserver/startClient.sh"
                tofile="${setupDir}/startClient.sh"/>
      </if>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/linuxserver/openpetraorg-server.sh"
                  tofile="${setupDir}/openpetraorg-server.sh"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/linuxserver/initpg.sh"
                  tofile="${setupDir}/initpg.sh"/>
      <copy file="${dir.bin}/setup/petra${PetraRelease}/linuxserver/initmysql.sh"
                  tofile="${setupDir}/initmysql.sh"/>
      <if test="${platform::is-unix()}">
        <!-- change the executable flag -->
        <ExecCmd program="sh" commandline="/C &quot;chmod a+x ${setupDir}/*.sh&quot;"/>
        <!-- make sure that the script files are in unix format -->
        <ExecCmd program="sh" commandline="/C &quot;for f in ${setupDir}/*.sh; do dos2unix -o $f; done;&quot;"/>
        <ExecCmd program="sh" commandline="/C &quot;cd ${setupDir}/etc30; ln -s PetraServerConsole-postgresql.config PetraServerConsole.config&quot;"/>
        
        <ExecCmd program="sh" commandline="/C &quot;cd ${setupDir}/..; tar czpf ${dir.setup}/openpetraorg-mono-${ReleaseID}.tar.gz *&quot;"/>

        <!-- to avoid problem with symbolic link with delete dir task -->
        <ExecCmd program="sh" commandline="/C &quot;cd ${setupDir}/etc30; rm PetraServerConsole.config&quot;"/>
      </if>
    </if>
    <if test="${SkipDatabases=='true'}">
      <!-- this can be useful if we just need the binary files and not the scripts for an existing Linux OpenPetra server to update -->
      <tar destfile="${dir.setup}/openpetraorg-server-update-${ReleaseID}.tar.gz" compression="GZip">
          <fileset basedir="${setupDir}" prefix="openpetraorg-${ReleaseID}">
              <include name="**/*" />
          </fileset>
      </tar>
    </if>
  </if>
  <if test="${BuildClientArchive}">
    <!-- this does not keep the executable flag; need this to make the patch for windows clients -->
    <tar destfile="${dir.setup}/openpetraorg-client-backup-${ReleaseID}.tar.gz" compression="GZip">
        <fileset basedir="${setupDir}" prefix="openpetraorg-${ReleaseID}">
            <include name="**/*" />
        </fileset>
    </tar>
  </if>
</target> 
<!-- END buildRelease -->

<target name="quickCompile">
  <!-- this is very different from the compile target. quickCompile does not generate any code. 
       quickCompile uses the solution and csproj files and msbuild.
       quickCompile is intended as an alternative to compile in SharpDevelop directly.
  -->
  <property name="solution" value="OpenPetra" overwrite="false"/>
  <property name="solution.file" value="${path::combine(dir.projectfiles,
                                path::combine(devenv-name, 'OpenPetra.'+solution+'.sln'))}"/>
  <property name="solution.file" value="${string::replace(solution.file, 'OpenPetra.OpenPetra.sln', 'OpenPetra.sln')}"/>
  <if test="${framework::get-target-framework() == 'mono-2.0'}" >
    <if test="${property::exists('xbuild')}">
      <exec program="${xbuild}" commandline="${solution.file}">
         <environment>
           <variable name="MONO_PATH" value="${NAntBin.dir}"/> <!-- variable does not exist yet; otherwise: value="${NAntBin.dir}:${environment::get-variable('MONO_PATH')}" -->
         </environment>
      </exec>
    </if>
  </if>
  <if test="${string::starts-with(framework::get-target-framework(), 'net-')}" >
    <if test="${file::exists(msbuildtask.file)}">
      <msbuild project="${solution.file}" verbosity="Minimal">
        <property name="Configuration" value="${Configuration}"/>
      </msbuild>
    </if>
    <if test="${not file::exists(msbuildtask.file)}">
      <solution configuration="${Configuration}" solutionfile="${solution.file}" />
    </if>
  </if>
</target>

<target name="generateORM" depends="generateORMCachedTables,generateORMData,generateORMAccess">
  <echo message="please compile the code after the files have been regenerated"/>
</target>

<target name="generateORMData">
  <!-- generate the files for Ict.Petra.Shared.lib.data, ie. the tables and datasets -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Shared/Ict.Petra.Shared.build')}" verbose="${verbose}"/>
</target>

<target name="generateORMAccess">
  <!-- generate the files for Ict.Petra.Server.lib.data, ie. the access files for reading from and writing to the database -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Server/Ict.Petra.Server.build')}" verbose="${verbose}"/>
</target>

</project>

