<?xml version="1.0"?>
<project name="OpenPetra" default="help">

<echo>operating system=${operating-system::to-string(environment::get-operating-system())}</echo>
<echo>platform=${platform::get-name()}</echo>


<include buildfile="inc/nant/OpenPetra.common.xml"/>

<!-- nant -projecthelp does not show imported targets-->
<target name="help" depends="" description="Displays the available targets and parameters.">
    <echo>
list of available commands:
  clean: cleans everything
  compile: compiles OpenPetra including testing
  generateTools: build the basic tools only
  generateSolution: compiles OpenPetra and generates the project and solution files
  generateSolutionNoCompile: generates the project and solution files. minimalGenerateSolution should already be executed
  minimalGenerateSolution: generates the project and solution files. compiles what it needs, but does not compile all code
  quickCompile: will just compile the solution file, with msbuild (Windows) or xbuild (Linux)
      nant quickCompile                    will compile the OpenPetra.sln
      nant quickCompile -D:solution=Tools  will compile the OpenPetra.Tools.sln
                                           other solutions are: Client, Server, Testing
  quickClean: cleans all generated files and the delivery directory
  startPetraServer: run a local Petra Server
  stopPetraServer: stop the local Petra Server
  startPetraClient: run the Petra Client
  deleteBakFiles: delete all backup files
  initConfigFiles: write and overwrite the config files for client, server and testing, and the version.txt

compat:
  createSQLStatements: generates the sql create table statements etc from the petra.xml
  dbdoc: generates database design documentation using sql2diagram
  schemaSpy: generates database documentation using schemaSpy
  recreateDatabase: needed after changes in table structure in petra.xml
  resetDatabase: just resets the data, resets the permissions
  patchDatabase: update the database to the latest development version
  dumpDatabase: dump the database to a db specific format.
        nant dumpDatabase -D:OutputDB.file=test.sql
  loadDatabase: load the database from a db specific dump
        nant loadDatabase -D:LoadDB.file=test.sql
  generateORM: generates Object Relational Mapping routines from petra.xml
    sub items: generateORMCachedTables, generateORMData, generateORMAccess
  generateGlue: generates the interfaces and instantiators, which is the glue between client and server
  generateWinforms: generates all yaml files in csharp\ICT\Petra\Client
  generateWinform: generate a single yaml file, and optionally compile and start the client
       nant generateWinform startPetraClient -D:file=MFinance/Gui/GL/GLBatch.yaml
       nant generateWinform -D:file=MFinance/Gui/GL/GLBatch.yaml -D:donotcompile=true
  cleanPetra: prepare for a clean build
  compilePetra: build all Petra C# code
  translationCompilePOFile: create the dlls required to be delivered with a new release
  translation: extracts string in winforms, creates and updates the .po files, and compiles the dll files for delivery

releases:
  buildWindowsStandalone: uses InnoSetup, therefore only works on Windows
  buildLinuxSourceforgeRelease: will build the linux files that we upload to Sourceforge. creates tar files for local server and client
  buildRemoteInstallers -D:ReleaseID=0.0.2.0 -D:OrgName=&quot;Your Organisation&quot; -D:PublisherUrl=www.ProviderWebsite.com -D:HostedServer=app.Provider.com -D:HostedPort=9000 -D:WithLinuxClient=false

list of commands, which works in the specific csharp directories:
  indent: beautify the code according to coding style guide
  uncrustify: calls indent

not supported
  loc, ploc: count the lines of code, to be used for COCOMO etc
  generateWebforms: generates the User Interface using the Ext.js AJAX framework
  generateWebform: generate a single Webform. requires parameter: -D:file=SampleApplicationForm
  startWebServer: start a webservice with Mono XSP and Postgresl (does not work with sqlite at the moment)
  createPatch: requires these parameters: -D:OldVersion=0.0.8-1 -D:NewVersion=0.0.10-0

useful parameters
  -logfile:test.log
</echo>
</target>

<target name="apiDoc" description="Generates API documentation. nant depend should have been run" >
  <exec program="${external.doxygen}">
    <arg value="&quot;${external.doxygen.configfile}&quot;" />
  </exec>  
</target>

<target name="translationCompilePOFile" description="create the dlls with the i18n messages" >
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="i18n/i18n.build" />
</target>

<target name="custclean" description="Cleans the solution and project files">
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <delete>
      <fileset basedir="${path::combine(dir.projectfiles,devenv-name)}">
        <include name="OpenPetra*.sln" />
        <include name="*.csproj" />
      </fileset>
    </delete>
  </foreach>
  <delete> 
    <fileset basedir="${dir.delivery}" >  
      <include name="OpenPetraSetup-*.exe" />
    </fileset>
  </delete>
  <property name="target" value="clean" />
  <call target="translationCompilePOFile" />
</target>

<target name="quickClean" description="cleans all generated files and the delivery directory">
  <!-- Do not remove dir.delivery, because this would change all UUIDs from the project files -->
  <delete dir="${dir.bin}"/>
  <delete file="${namespaceFile}"/>
  <delete file="${projectDependenciesFile}"/>
  <foreach item="String" property="devenv-name" delim="," in="${projectfiles.templates-list}" >
    <delete dir="${path::combine(dir.projectfiles,devenv-name)}" />
  </foreach>
  <delete>
    <fileset basedir="${dir.root}">
      <include name="**/*-generated.build" />
      <include name="**/*-generated.cs" />
      <include name="**/*-generated.resx" />
      <include name="**/*-generated.Designer.cs" />
      <include name="**/*.generated.refs" />
      <include name="tmp/**/AssemblyInfo.cs" />
    </fileset>
  </delete>
</target>

<target name="nanttasks" depends="" description="goes into the directory inc/nanttasks">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="inc/nanttasks/nanttasks.build" />
</target>

<target name="csharp" depends="nanttasks" description="goes into the directory csharp">
  <property name="target" value="compile" overwrite="false" />
  <nant inheritall="false" target="${target}" 
        buildfile="csharp/csharp.build" />
</target>

<target name="internal-subdirs" description="Goes into all necessary subdirectories" 
        depends="csharp,nanttasks" />

<target name="generateSolutionNoCompile" description="generates the project and solution files. minimalGenerateSolution should already be executed"
        depends="nanttasks,generateNamespaceMap,generateProjectFiles"/>

<target name="minimalGenerateSolution" description="compile minimal code for generating source code and the project and solution files">
    <call target="nanttasks"/>
    <call target="generateTools"/>
    <call target="generateWinforms"/>
    <call target="generateORM"/>
    <!-- need to call generateNamespaceMap again, even though it was called in generateTools already. but now the winforms and ORM have been generated -->
    <call target="generateNamespaceMap"/>
    <call target="generateProjectFiles"/>
</target>

<target name="generateSolution" description="compiles OpenPetra and generates the project and solution files"
        depends="minimalGenerateSolution">
    <call target="quickCompile"/>
</target>

<target name="generateNamespaceMap">
  <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('GenerateNamespaceMap')}"/>
  <GenerateNamespaceMap
    CodeRootDir="${dir.csharp}"
    NamespaceMapFilename="${namespaceFile}"
    NamespaceMap3rdParty="${namespaceFile3rdParty}"
    DependencyMapFilename="${projectDependenciesFile}"/>
</target>

<target name="generateTools">
  <call target="nanttasks"/>
  <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('GenerateNamespaceMap')}"/>
  <GenerateNamespaceMap
    CodeRootDir="${dir.csharp}"
    NamespaceMapFilename="${namespaceFile}"
    NamespaceMap3rdParty="${namespaceFile3rdParty}"
    DependencyMapFilename="${projectDependenciesFile}"
    ShowWarnings="false"
    LimitToNamespaces="Ict.Common,Ict.Common.IO,Ict.Common.DB,Ict.Tools*"/>
  <nant inheritall="false" target="compile" 
        buildfile="csharp/ThirdParty/ThirdParty.build" />
  <call target="generateProjectFiles"/>
  <call target="quickCompile"/>
</target>

<target name="generateProjectFiles">
  <loadtasks assembly="${Ict.Tools.NAntTasks.DLL}" unless="${task::exists('GenerateProjectFiles')}"/>
  <GenerateProjectFiles 
    CodeRootDir="${dir.csharp}"
    DependencyMapFilename="${projectDependenciesFile}"
    GUIDMapFilename="${uuidFile}"
    TemplateDir="${dir.incdir.template}"
    DevEnvironments="${projectfiles.templates-list}"
    DirBin="${dir.bin}"
    DirProjectFiles="${dir.projectfiles}"
    NetFrameworkVersion="${NETframework-version}"
    ProjectVersion="${ReleaseID}"
    />
</target>

<!-- Include default implementation -->
<include buildfile="inc/nant/OpenPetra.subdirs.xml"/> 

<!-- Compat targets -->
<include buildfile="inc/nant/OpenPetra.tobe.migrated.xml"/>

<!-- tasks for building releases -->
<include buildfile="setup/setup.build"/>

<target name="quickCompile">
  <!-- this is very different from the compile target. quickCompile does not generate any code. 
       quickCompile uses the solution and csproj files and msbuild.
       quickCompile is intended as an alternative to compile in SharpDevelop directly.
  -->
  <property name="solution" value="OpenPetra" overwrite="false"/>
  <if test="${not platform::is-windows()}" >
    <property name="solution.file" value="${path::combine(dir.projectfiles,
                                  path::combine(devenv-xbuild, 'OpenPetra.'+solution+'.sln'))}"/>
    <property name="solution.file" value="${string::replace(solution.file, 'OpenPetra.OpenPetra.sln', 'OpenPetra.sln')}"/>
    <exec program="xbuild" commandline="${solution.file}"/>
  </if>
  <if test="${platform::is-windows()}" >
    <property name="solution.file" value="${path::combine(dir.projectfiles,
                                path::combine(devenv-msbuild, 'OpenPetra.'+solution+'.sln'))}"/>
    <property name="solution.file" value="${string::replace(solution.file, 'OpenPetra.OpenPetra.sln', 'OpenPetra.sln')}"/>
    <if test="${file::exists(msbuildtask.file)}">
      <msbuild project="${solution.file}" verbosity="Minimal">
        <property name="Configuration" value="${Configuration}"/>
      </msbuild>
    </if>
    <if test="${not file::exists(msbuildtask.file)}">
      <fail message="you need the NAnt.Contrib.Tasks.dll for msbuild" />
    </if>
  </if>
</target>

<target name="generateORM" depends="generateORMCachedTables,generateORMData,generateORMAccess">
  <echo message="please compile the code after the files have been regenerated"/>
</target>

<target name="generateORMData">
  <!-- generate the files for Ict.Petra.Shared.lib.data, ie. the tables and datasets -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Shared/Ict.Petra.Shared.build')}" verbose="${verbose}"/>
</target>

<target name="generateORMAccess">
  <!-- generate the files for Ict.Petra.Server.lib.data, ie. the access files for reading from and writing to the database -->
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Server/Ict.Petra.Server.build')}" verbose="${verbose}"/>
</target>

<target name="generateWinforms">
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Client/Ict.Petra.Client.build')}" verbose="${verbose}"/>
  <nant inheritall="false" target="custdepend" buildfile="${path::combine(dir.csharp, 'ICT/Petra/PetraClient/PetraClient.build')}" verbose="${verbose}"/>
</target>

<target name="generateWinform">
  <nant inheritall="true" target="generateWinform" buildfile="${path::combine(dir.csharp, 'ICT/Petra/Client/Ict.Petra.Client.build')}" verbose="${verbose}"/>
</target>

</project>

